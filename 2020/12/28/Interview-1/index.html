<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/panda-180-3.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/panda-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/panda-16.png">
  <link rel="mask-icon" href="/images/panda.svg" color="#222">
  <meta name="baidu-site-verification" content="m1ei8mEvXD">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mxxct4git.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Interview-11. 线程的状态 新建(NEW)：新建一个线程 可运行(RUNNABLE)：调用start，等待cpu的使用权 运行(RUNNING)：可运行(RUNNABLE)的线程拿到cpu时间片，开始执行 阻塞(BLOCKED)：指线程因为某种原因放弃了cpu 使用权，即让出了cpu时间片 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(w">
<meta property="og:type" content="article">
<meta property="og:title" content="Interview-1">
<meta property="og:url" content="https://mxxct4git.github.io/2020/12/28/Interview-1/index.html">
<meta property="og:site_name" content="猫熊小才天の书院">
<meta property="og:description" content="Interview-11. 线程的状态 新建(NEW)：新建一个线程 可运行(RUNNABLE)：调用start，等待cpu的使用权 运行(RUNNING)：可运行(RUNNABLE)的线程拿到cpu时间片，开始执行 阻塞(BLOCKED)：指线程因为某种原因放弃了cpu 使用权，即让出了cpu时间片 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(w">
<meta property="og:locale">
<meta property="og:image" content="https://images.weserv.nl/?url=http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg">
<meta property="og:image" content="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/1088206/201810/1088206-20181009103259832-1994410944.jpg">
<meta property="og:image" content="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20200709203708724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ0Nzk1OQ==,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images.weserv.nl/?url=https://images2015.cnblogs.com/blog/820406/201603/820406-20160326200119386-756216654.png">
<meta property="og:image" content="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20190212140504667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTI0NjYx,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://images.weserv.nl/?url=https://img3.sycdn.imooc.com/5d24c29b0001590909470341.jpg">
<meta property="article:published_time" content="2020-12-28T05:54:24.000Z">
<meta property="article:modified_time" content="2021-01-19T12:55:32.000Z">
<meta property="article:author" content="Mxxct">
<meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.weserv.nl/?url=http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg">

<link rel="canonical" href="https://mxxct4git.github.io/2020/12/28/Interview-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Interview-1 | 猫熊小才天の书院</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">猫熊小才天の书院</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mxxct4git.github.io/2020/12/28/Interview-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda-180.png">
      <meta itemprop="name" content="Mxxct">
      <meta itemprop="description" content="君子不器">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫熊小才天の书院">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Interview-1
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-28 13:54:24" itemprop="dateCreated datePublished" datetime="2020-12-28T13:54:24+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-19 20:55:32" itemprop="dateModified" datetime="2021-01-19T20:55:32+08:00">2021-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          
            <span id="/2020/12/28/Interview-1/" class="post-meta-item leancloud_visitors" data-flag-title="Interview-1" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/12/28/Interview-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/28/Interview-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Interview-1"><a href="#Interview-1" class="headerlink" title="Interview-1"></a>Interview-1</h2><h3 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h3><ul>
<li>新建(NEW)：新建一个线程</li>
<li>可运行(RUNNABLE)：调用start，等待cpu的使用权</li>
<li>运行(RUNNING)：可运行(RUNNABLE)的线程拿到cpu时间片，开始执行</li>
<li>阻塞(BLOCKED)：指线程因为某种原因放弃了cpu 使用权，即让出了cpu时间片<ul>
<li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中</li>
<li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>
<li>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ul>
</li>
<li>终止(DEAD)</li>
</ul>
<p><img src="https://images.weserv.nl/?url=http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg"></p>
<h3 id="2-死锁的现象和解决方法"><a href="#2-死锁的现象和解决方法" class="headerlink" title="2. 死锁的现象和解决方法"></a>2. 死锁的现象和解决方法</h3><p>死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。</p>
<p>死锁产生的四个必要条件：</p>
<ul>
<li>互斥：共享资源同时只能被一个线程访问</li>
<li>占有且等待：线程T1在取得共享资源A的时候，请求等待资源B的时候并不释放资源A。</li>
<li>不可抢占：其他线程不能强行抢占线程的资源。</li>
<li>循环等待条件：线程T1在持有资源A1，同时在请求等待获取资源B，线程T2在持有资源B,然后在请求等待线程T1的持有资源，形成了交叉闭环申请。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>预防<ul>
<li>打破互斥条件。即允许进程同时访问某些资源。但是很多情况有些资源是不支持同时访问的。这个方法基本没用</li>
<li>打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。<strong>当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程</strong>。相当于线程占有的资源被隐蔽强占了。这个方法实现困难，会降低性能</li>
<li>打破占有且等待条件。可以实行资源预先分配策略。如果一个线程所申请的所需的全部资源得不到满足，则不分配任何资源，线程不运行。这个方法会降低线程的并发性</li>
<li>打破循环等待条件，实行资源有序分配策略。需要提前对资源进行分类编号，增加系统开销</li>
</ul>
</li>
<li>避免<ul>
<li>允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待。安全序列的定义：所谓系统是安全的，是指系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列{P1，P2，…，Pn}就是安全序列。如果存在这样一个安全序列，则系统是安全的；如果系统不存在这样一个安全序列，则系统是不安全的。</li>
</ul>
</li>
<li>检测与恢复<ul>
<li>通过检测算法建立线程等待图，如果出现环路则表示有死锁。</li>
<li>通过抢占资源、回退执行、杀掉进程三种方式实现恢复</li>
</ul>
</li>
</ul>
<blockquote>
<p>预防是排除死锁的静态策略，基本没啥用。避免是动态策略，是对线程申请资源这个操作加以限制。但是系统具有并发、共享和随机性等特点，所以也很难实现。主要是检测与恢复，能发现死锁并从死锁中恢复出来。</p>
</blockquote>
<h3 id="3-ConcurrentHashMap-的数量"><a href="#3-ConcurrentHashMap-的数量" class="headerlink" title="3. ConcurrentHashMap 的数量"></a>3. ConcurrentHashMap 的数量</h3><p>由于调用方法的时候可能并发进行增删操作，所以这个数量只是一个估值。</p>
<p>一共有两种方式来获取数量，一个是 <code>size()</code>，如果数量大于int的最大值返回int最大值，根据JDK8注释来看，应该用 <code>mappingCount()</code> 来取代 <code>size()</code>。两个方法底层调用的都是 <code>sumCount()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;  </span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;  <span class="comment">// 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新，但它并不用返回当前hashmap的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)  </span><br><span class="line">                sum += a.value; <span class="comment">//所有counter的值求和  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sum;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次put操作都会调用 <code>addCount()</code>，通过cas来累加 baseCount，然后查看是否需要扩容。在并发时如果利用CAS修改baseCount失败，会利用CAS操作修改CountCell的值。</p>
<h3 id="4-cas"><a href="#4-cas" class="headerlink" title="4. cas"></a>4. cas</h3><p>基于调用JNI代码实现，借助C来调用CPU底层指令实现。高效轻量，但是有三个问题</p>
<ul>
<li>ABA：借助AtomicStampedReference来解决</li>
<li>循环时间可能很长：</li>
<li>只能保证一个共享变量的原子操作。可以将多个共享变量合并成一个，或者借助AtomicReference类保证引用对象之间的原子性，把多个变量放在一个对象里进行cas操作</li>
</ul>
<h3 id="5-concurrentHashMap-1-7-和-1-8-区别"><a href="#5-concurrentHashMap-1-7-和-1-8-区别" class="headerlink" title="5. concurrentHashMap 1.7 和 1.8 区别"></a>5. concurrentHashMap 1.7 和 1.8 区别</h3><ul>
<li>整体结构<ul>
<li>1.7：segment + hashEntry + unsafe</li>
<li>1.8：移除 segment，使锁的粒度更小， synchronized + CAS + node数组 + unsafe</li>
</ul>
</li>
<li>put<ul>
<li>1.7：先定位segment，再定位桶，全程加锁</li>
<li>1.8：类似于HashMap，直接定位到桶，拿到first节点后进行判断，1、为空则CAS插入；2、为-1则说明在扩容，则跟着一起扩容；3、else则加锁put（类似1.7）</li>
</ul>
</li>
</ul>
<h3 id="6-如何在很短的时间内将大量数据插入到ConcurrentHashMap-如何提高concurrentHashMap的插入效率"><a href="#6-如何在很短的时间内将大量数据插入到ConcurrentHashMap-如何提高concurrentHashMap的插入效率" class="headerlink" title="6. 如何在很短的时间内将大量数据插入到ConcurrentHashMap &#x2F; 如何提高concurrentHashMap的插入效率"></a>6. 如何在很短的时间内将大量数据插入到ConcurrentHashMap &#x2F; 如何提高concurrentHashMap的插入效率</h3><p>主要有两个地方消耗会比较大。一个是扩容操作，一个是锁资源竞争。扩容问题可以通过配置合理的容量大小和扩容因子，尽量减少扩容。锁资源争夺问题，主要是put时会对头结点加上synchronized，优化的一个点可以是锁的等级。将数据根据hash先分类，hash冲突的数据保存在一起，然后使用单线程来put，这样put锁的是同一个头结点，可以将锁控制在偏向锁级别。</p>
<blockquote>
<p>synchronized 级别：偏向锁 -&gt; 轻量锁 -&gt; 重量锁。<br>偏向锁：偏指的是偏向于第一个访问的线程。在无竞争的环境下，有一个线程访问的同步代码块，这个锁就会偏向这个线程，下次访问的时候会检查对象头的mark word记录的是否是当前线程ID，如果是的话就会保持偏向锁，并执行同步代码块。但如果不是偏向锁，就会通过cas来替换线程ID，此时就可能会升级为轻量锁。</p>
</blockquote>
<p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/1088206/201810/1088206-20181009103259832-1994410944.jpg"></p>
<h3 id="7-线程池对工作线程的回收"><a href="#7-线程池对工作线程的回收" class="headerlink" title="7. 线程池对工作线程的回收"></a>7. 线程池对工作线程的回收</h3><blockquote>
<p>线程池的创建主要是通过 ThreadPoolExecutor 这个类来创建的，Executors 类也可以创建，但是不能自定义，类型有限</p>
</blockquote>
<p>线程启动后，就会进入到 <code>runWorker(Worker w)</code> 方法。里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行 <code>processWorkerExit(w, completedAbruptly);</code> 在这个方法里把工作线程移除掉。</p>
<p>获取任务主要是 <code>getTask()</code> 方法（还有一个 firstTask，只会执行一次），在不考虑异常的场景下，返回null，就表示退出循环，结束线程。下一步，就得看看，什么情况下 <code>getTask()</code> 会返回null。</p>
<p>两种情况</p>
<ul>
<li>线程池的状态已经是STOP，TIDYING, TERMINATED，或者是SHUTDOWN且工作队列为空</li>
<li>工作线程数已经大于最大线程数或当前工作线程已超时，且，还有其他工作线程或任务队列为空。</li>
</ul>
<blockquote>
<p>当线程池中的线程数小于corePoolSize 时，新提交的任务直接新建一个线程执行任务（不管是否有空闲线程）<br>当线程池中的线程数等于corePoolSize 时，新提交的任务将会进入阻塞队列（workQueue）中，等待线程的调度<br>当阻塞队列满了以后，如果corePoolSize &lt; maximumPoolSize ,则新提交的任务会新建线程执行任务，直至线程数达到maximumPoolSize<br>当线程数达到maximumPoolSize 时，新提交的任务会由(饱和策略)管理<br>任务就理解为生产者消费者中的同步队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">    &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">        workQueue.take();</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    timedOut = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">    timedOut = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果设置了 <code>allowCoreThreadTimeOut(true)</code> 或者当前运行的线程数大于核心线程数，<code>timed = true</code> 此时将从 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 队列里拿出来一个线程执行，如果在规定时间内没取到，就返回null；否则就会 <code>workQueue.take();</code> 所以线程池里的线程一直在等待任务执行不被销毁是因为进入了阻塞状态</p>
<blockquote>
<p>workQueue 一般是 arrayBlockingQueue(或者 linkedBlockingQueue)，至少也是一个阻塞的，当篮子里没有消息的时候，也就是 getTask()</p>
</blockquote>
<h3 id="8-数据库的脏读、不可重复读和幻读"><a href="#8-数据库的脏读、不可重复读和幻读" class="headerlink" title="8. 数据库的脏读、不可重复读和幻读"></a>8. 数据库的脏读、不可重复读和幻读</h3><ul>
<li>脏读：一个事务读取到另一个事务没有提交的数据。我们举个例子：事务A1修改了一行数据，但是还没有提交(还没写入硬盘），这时候事务A2读取了被事务A1修改后的数据，之后事务T1因为一些原因Rollback回滚了，那么事务T2读取的数据就是脏的。<ul>
<li>解决：事务隔离级别调整到READ_COMMITTED</li>
</ul>
</li>
<li>不可重复读：指的是同一个事务， 相同的查询过程读取出了不同的结果。比如说，事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。<ul>
<li>解决：事务隔离级别调整到REPEATABLE_READ</li>
</ul>
</li>
<li>幻读：指的是事务不独立执行的时候，可能出现的错误。比如：A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。<ul>
<li>解决：事务隔离级别调整到SERIALIZABLE_READ</li>
</ul>
</li>
</ul>
<p>隔离级别：</p>
<ul>
<li>DEFAULT</li>
<li>READ_UNCOMMITTED：读未提交，即能够读取到没有被提交的数据，啥也解决不了，很少用</li>
<li>READ_COMMITED：读已提交，即能够读到那些已经提交的数据，自然能够防止脏读</li>
<li>REPEATABLE_READ：重复读取，即在数据读出来之后加锁，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录</li>
<li>SERLALIZABLE：串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务</li>
</ul>
<h3 id="9-TCP和UDP"><a href="#9-TCP和UDP" class="headerlink" title="9. TCP和UDP"></a>9. TCP和UDP</h3><ul>
<li>TCP：面向连接，三次握手，传输可靠</li>
<li>UDP：传输数据前不需要建立连接，适合传输大量数据，但是不可靠，容易丢包，比如直播视频，丢帧就丢了</li>
</ul>
<h3 id="10-BIO、NIO、AIO-select-poll、epoll"><a href="#10-BIO、NIO、AIO-select-poll、epoll" class="headerlink" title="10. BIO、NIO、AIO &amp; select&#x2F;poll、epoll"></a>10. BIO、NIO、AIO &amp; select&#x2F;poll、epoll</h3><p>举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（<strong>同步阻塞</strong>）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（<strong>同步非阻塞</strong>）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（<strong>异步非阻塞</strong>）。</p>
<ul>
<li>BIO：同步阻塞。通过线程池的方式来对每一个请求提供应答，但是无法应对海量的请求并发</li>
<li>NIO：同步非阻塞。在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。  <ul>
<li>NIO 和 BIO 的区别：<ul>
<li>IO流是阻塞的，NIO流是非阻塞的</li>
<li>IO面向流，而NIO面向缓冲区。所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</li>
<li>NIO 通过Channel（通道） 进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</li>
<li>NIO有选择器，而IO没有。选择器用于使用单个线程处理多个通道。避免了线程之间的切换，可以直接将线程通过select挂在到不同的channel下</li>
</ul>
</li>
<li>NIO 读写数据的方式<ul>
<li>从channel读取：创建一个缓冲区，请求通道读取数据</li>
<li>从channel写入：创建一个缓冲区，填充数据，并要求通道写入数据<blockquote>
<p>NIO 底层是由 epoll 实现，但是空轮询会导致cpu飙升 &#x3D;&#x3D;&gt; netty</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>AIO：异步非阻塞。协程</li>
</ul>
<p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20200709203708724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ0Nzk1OQ==,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>同步阻塞IO：请求数据的线程会一直阻塞，知道准备好数据</li>
<li>同步非阻塞IO：用户态请求数据，如果内核态数据没准备好，用户态的线程可以去做别的，但是会不断询问数据是否准备好</li>
<li>多路复用IO（NIO）：用户态线程不断去询问，消耗CPU资源 &#x3D;&#x3D;&gt; 有三种方式（select、poll、epoll），根本思想是将用户态的不断轮询交给内核态去做，其中selcet\poll是轮询的方式，epoll不是轮询。内核态准备好数据后，也不需要只找那个请求数据的线程，找其他用户态等着的线程来处理接下来的事情就好。<ul>
<li>select：把需要的数据fd放到一个set里，因为是set所以有数量限制，在内核态不断轮询。缺点是线性轮询，效率低；用户态和内核态的复制非常消耗资源</li>
<li>poll：将set替换为链表的方式，这样就没有数量限制</li>
<li>epoll：示例如Nginx。不像前两个把fd放到一个集合里遍历，而是采用<strong>注册回调函数</strong>，在fd准备好的时候触发回调函数，把fd放到就绪队列，直接返回，这样就避免了遍历所有的fd，时间从O(n)变到O(1)</li>
</ul>
</li>
</ul>
<h3 id="11-linux下的java进程和linux线程有一一对应的关系吗"><a href="#11-linux下的java进程和linux线程有一一对应的关系吗" class="headerlink" title="11. linux下的java进程和linux线程有一一对应的关系吗"></a>11. linux下的java进程和linux线程有一一对应的关系吗</h3><p>如果线程有50%的时间被阻塞，线程的数量就应该是内核数量的2倍。如果更少的比例被阻塞，那么它们就是计算密集型的，则需要开辟较少的线程。如果有更多的时间被阻塞，那么就是IO密集型的程序，则可以开辟更多的线程。于是我们可以得到下面的线程数量计算公式：</p>
<p>线程数量&#x3D;内核数量 &#x2F; （1 - 阻塞率）</p>
<h3 id="12-JVM-哪一些是线程独占哪一些是线程共享"><a href="#12-JVM-哪一些是线程独占哪一些是线程共享" class="headerlink" title="12. JVM 哪一些是线程独占哪一些是线程共享"></a>12. JVM 哪一些是线程独占哪一些是线程共享</h3><p><img src="https://images.weserv.nl/?url=https://images2015.cnblogs.com/blog/820406/201603/820406-20160326200119386-756216654.png"></p>
<ul>
<li><p>线程独占：栈、本地方法栈、程序计数器</p>
</li>
<li><p>线程独享：堆、方法区</p>
</li>
<li><p>栈：线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。</p>
</li>
<li><p>本地技术栈：和Native方法有关</p>
</li>
<li><p>程序计数器：PC寄存器，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。</p>
</li>
<li><p>堆：所有线程共享，所有的对象和数组都在堆上进行分配。</p>
</li>
<li><p>方法区：主要用于存储类的信息、常量池、方法数据、方法代码等</p>
</li>
</ul>
<h3 id="13-JDK8-永久代和元空间"><a href="#13-JDK8-永久代和元空间" class="headerlink" title="13. JDK8 永久代和元空间"></a>13. JDK8 永久代和元空间</h3><p>永久代（PermGen space）：指的是方法区，但是和方法区有本质的区别。方法区是JVM的规范，永生代是JVM规范的一种实现，并且只有 HotSpot 才有永生代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。</p>
<blockquote>
<p>JVM 是一种规范，hotspot是虚拟机的一种实现方式。openjdk项目包括hostspot这个组件</p>
</blockquote>
<p>在JDK8中，HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。</p>
<p>元空间（Metaspace）：7将永久代移动到了堆（比如字符串常量移到了堆），8已经不存在永久代了。元空间的本质和永久代类似，都是对方法区的一种实现，但是最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此默认情况下，元空间的大小仅受本地内存限制，但是可以通过参数来指定元空间的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</span><br><span class="line"></span><br><span class="line">除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</span><br><span class="line">-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</span><br><span class="line">-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</span><br></pre></td></tr></table></figure>

<h3 id="14-Linux-分段"><a href="#14-Linux-分段" class="headerlink" title="14. Linux 分段"></a>14. Linux 分段</h3><h3 id="15-抽象类和接口"><a href="#15-抽象类和接口" class="headerlink" title="15. 抽象类和接口"></a>15. 抽象类和接口</h3><p>JDK8 允许在接口中定义 static 方法和 default 方法，其中default方法可以选择重写；static 方法比如通过接口类调用，原因是一个类可能实现两个接口，如果两个接口类中的static方法一样，就会发现错误，所以需要指定接口类来调用static方法</p>
<p>抽象类就是对一类事物的共性东西提取出来；接口则是一种规范，许多情况下接口可以代替抽象类，毕竟Java单继承多实现</p>
<h3 id="16-synchronized-和-ReentrantLock的区别"><a href="#16-synchronized-和-ReentrantLock的区别" class="headerlink" title="16. synchronized 和 ReentrantLock的区别"></a>16. synchronized 和 ReentrantLock的区别</h3><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ul>
<p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p>
<h3 id="17-怎么唤醒一个阻塞的线程"><a href="#17-怎么唤醒一个阻塞的线程" class="headerlink" title="17. 怎么唤醒一个阻塞的线程"></a>17. 怎么唤醒一个阻塞的线程</h3><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
<h3 id="18-int和Integer的区别，为什么有了int还要有设计Integer"><a href="#18-int和Integer的区别，为什么有了int还要有设计Integer" class="headerlink" title="18. int和Integer的区别，为什么有了int还要有设计Integer"></a>18. int和Integer的区别，为什么有了int还要有设计Integer</h3><p>区别：</p>
<ul>
<li>int 是基本数据类型， Integer 是包装类</li>
<li>Integer 必须实例化后才能使用</li>
<li>Integer 实际是对象的引用，指向new出来的对象；int 是直接存储数值</li>
<li>Integer 默认值是null， int默认值是0</li>
</ul>
<p>深入：</p>
<ul>
<li>两个通过new生成的Integer变量永远是不相等的。因为new生成的是两个对象，其内存地址不同。</li>
<li>Integer与new Integer不会相等。因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。</li>
<li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。<ul>
<li>java在编译Integer i &#x3D; 127的时候,被翻译成 Integer i &#x3D; Integer.valueOf(127);  java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127这个Integer对象进行缓存，下次再写Integer j &#x3D; 127时，就会直接从缓存中取，就不会new了。</li>
</ul>
</li>
<li>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true。（因为包装类Integer和基本数据类型int比较时，java会自动拆箱为int，然后进行比较，实际上就变为两个int变量的比较）</li>
</ul>
<p>对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。<br>另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。</p>
<h3 id="19-Executor封装的四种线程池类型"><a href="#19-Executor封装的四种线程池类型" class="headerlink" title="19. Executor封装的四种线程池类型"></a>19. Executor封装的四种线程池类型</h3><ul>
<li>newCachedThreadPool：可缓存的线程池，最大线程数无上限（int最大值）</li>
<li>newFixedThreadPool：固定大小的线程池，所有的线程都是核心线程，没有空闲等待时间</li>
<li>newSingleThreadExecutor：单线程的线程池，相当于单线程串行执行所有任务</li>
<li>newScheduledThreadPool：最大线程数无上限，可设置核心线程数。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h3 id="20-线程池为什么要使用阻塞队列而不使用非阻塞队列？"><a href="#20-线程池为什么要使用阻塞队列而不使用非阻塞队列？" class="headerlink" title="20. 线程池为什么要使用阻塞队列而不使用非阻塞队列？"></a>20. 线程池为什么要使用阻塞队列而不使用非阻塞队列？</h3><p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。<br>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。<br>使得在线程不至于一直占用cpu资源。</p>
<h3 id="21-常用的并发工具类有哪些？线程之间的互相通信"><a href="#21-常用的并发工具类有哪些？线程之间的互相通信" class="headerlink" title="21. 常用的并发工具类有哪些？线程之间的互相通信"></a>21. 常用的并发工具类有哪些？线程之间的互相通信</h3><ul>
<li>CountDownLatch<ul>
<li>就是一个线程等待，直到它所等待的其他线程都执行完成并且调用 countDown() 方法发出通知后，当前线程才可以继续执行</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123; &#125;; </span><br></pre></td></tr></table></figure></li>
<li>CyclicBarrier 是所有线程都在等待，一直到所有线程都准备好进入 await() 方法之后，所有线程同时开始执行</li>
<li>Semaphore</li>
<li>Exchanger</li>
<li>wait\notify\notifyAll</li>
</ul>
<p>CyclicBarrier 和 CountDownLatch 的区别</p>
<ul>
<li>CountDownLatch 只能计算一次，但是 CyclicBarrier 可以 reset</li>
<li>CyclicBarrier 还提供了其他方法，比如 getNumberWaiting 方法可以获得阻塞的线程个数</li>
</ul>
<h3 id="22-volatile"><a href="#22-volatile" class="headerlink" title="22. volatile"></a>22. volatile</h3><ol>
<li>保证可见性</li>
<li>禁止重排序。为了提高性能，系统自动重排序，但是 volatile 这条指令的位置是不可以被改变的。 <code>1 2 volatile 3 4</code> 1和2一定在volatile前面，3和4一定在volatile后面，但是1和2、3和4之前的顺序不能做保证，即可以做重排序</li>
</ol>
<h3 id="23-AQS"><a href="#23-AQS" class="headerlink" title="23. AQS"></a>23. AQS</h3><p><a href="https://juejin.cn/post/6844903903188746247">AQS解析</a></p>
<p>AQS 是一个用来构架锁和同步器的框架，支持三种同步方式</p>
<ul>
<li>独占式<ul>
<li>如 ReentrantLock</li>
</ul>
</li>
<li>共享式<ul>
<li>如 CountDownLatch</li>
</ul>
</li>
<li>组合式<ul>
<li>如 ReentrantReadWriteLock。ReadWriteLock 主要是为了读写锁分离，读锁是共享的，写锁是独占的</li>
</ul>
</li>
</ul>
<h3 id="24-synchronized-中的锁池和等待池"><a href="#24-synchronized-中的锁池和等待池" class="headerlink" title="24. synchronized 中的锁池和等待池"></a>24. synchronized 中的锁池和等待池</h3><p>JVM会为一个使用内部锁（synchronized）的对象维护两个集合，Entry Set 和 Wait Set</p>
<ul>
<li>Entry Set: 如果线程A已经持有了对象锁，此时如果有其他线程也想获得该对象锁的话，它只能进入Entry Set，并且处于线程的BLOCKED状态。</li>
<li>Wait Set: 如果线程A调用了wait()方法，那么线程A会释放该对象的锁，进入到Wait Set，并且处于线程的WAITING状态。</li>
</ul>
<p>对于Entry Set中的线程，当对象锁被释放的时候，JVM会唤醒处于Entry Set中的某一个线程，这个线程的状态就从BLOCKED转变为RUNNABLE。</p>
<p>对于Wait Set中的线程，当对象的notify()方法被调用时，JVM会唤醒处于Wait Set中的某一个线程，这个线程的状态就从WAITING转变为RUNNABLE；或者当notifyAll()方法被调用时，Wait Set中的全部线程会转变为RUNNABLE状态。所有Wait Set中被唤醒的线程会被转移到Entry Set中。</p>
<h4 id="24-1-wait-方法外面为什么是while循环而不是if判断"><a href="#24-1-wait-方法外面为什么是while循环而不是if判断" class="headerlink" title="24.1 wait()方法外面为什么是while循环而不是if判断"></a>24.1 wait()方法外面为什么是while循环而不是if判断</h4><p>普遍是多个线程生产，多个线程消费，如果用 if() 还有可能出现：当一个生产者放入数据后，两个消费者都 if 判断通过，然后过度消费的情况，同理过度生产情况。</p>
<h4 id="24-2-为什么要用notifyAll-方法，用notify-行吗"><a href="#24-2-为什么要用notifyAll-方法，用notify-行吗" class="headerlink" title="24.2 为什么要用notifyAll()方法，用notify()行吗"></a>24.2 为什么要用notifyAll()方法，用notify()行吗</h4><p>c1 c2 拿到锁，发现队列是空，全都 wait()<br>p1 拿到锁，生产，notify()<br>但是此时有可能 p2 也在 Entry Set 里等锁，p2 拿到锁，此时队列是满的，需要 wait()，此时 c1 c2 p2 都在等<br>如果这时候 c1 消费完了，notify()，如果这时候唤醒 p2 没问题，但如果唤醒 c2 会继续等待，万一 p1 不再生产，那么 c2 p2 就会互相等待，造成死锁 &#x3D;&gt; 使用 notifyAll() 的原因就是 notify() 非常容易导致死锁</p>
<h3 id="25-sleep-和-wait-的区别"><a href="#25-sleep-和-wait-的区别" class="headerlink" title="25. sleep 和 wait 的区别"></a>25. sleep 和 wait 的区别</h3><p>如果线程持有某个对象的监视器，那么sleep不会放弃这个对象的监视器，而 wait 会放弃这个监视器。其实就是锁，sleep 不会释放锁</p>
<h3 id="26-线程类的构造方法、静态块是被哪个线程调用的"><a href="#26-线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="26. 线程类的构造方法、静态块是被哪个线程调用的"></a>26. 线程类的构造方法、静态块是被哪个线程调用的</h3><p>线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用</p>
<p>假设 Thread2 中 new 了 Thread1，main 函数中 new 了 Thread2，那么</p>
<ol>
<li>Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run() 方法是Thread2 自己调用的</li>
<li>Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run() 方法是Thread1 自己调用的</li>
</ol>
<h3 id="27-设计模式"><a href="#27-设计模式" class="headerlink" title="27. 设计模式"></a>27. 设计模式</h3><p>IOC的工厂模式、bean单例模式、装饰者模式、AOP动态代理等。<br>nio：反应器模式<br>redis：基于Reactor模式</p>
<h3 id="28-Redis-线程模型"><a href="#28-Redis-线程模型" class="headerlink" title="28. Redis 线程模型"></a>28. Redis 线程模型</h3><p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20190212140504667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTI0NjYx,size_16,color_FFFFFF,t_70"></p>
<p>每一个socket对应的fd会注册到epoll中，epoll会监听哪一个socket发送了命令，然后命令会进入队列，被顺序执行。整个过程只在调用select、poll、epoll的时候才会阻塞，socket不会阻塞，收发客户消息不会阻塞，这就是事件驱动，也就是 reactor 模式。</p>
<h3 id="30-并发修改数据库并回写Redis-如何保证数据一致性"><a href="#30-并发修改数据库并回写Redis-如何保证数据一致性" class="headerlink" title="30. 并发修改数据库并回写Redis 如何保证数据一致性"></a>30. 并发修改数据库并回写Redis 如何保证数据一致性</h3><h3 id="31-redis的hash怎么实现的，rehash过程讲一下-和JavaHashMap的rehash有什么区别？redis-cluster怎么做到高可用的？"><a href="#31-redis的hash怎么实现的，rehash过程讲一下-和JavaHashMap的rehash有什么区别？redis-cluster怎么做到高可用的？" class="headerlink" title="31. redis的hash怎么实现的，rehash过程讲一下 和JavaHashMap的rehash有什么区别？redis cluster怎么做到高可用的？"></a>31. redis的hash怎么实现的，rehash过程讲一下 和JavaHashMap的rehash有什么区别？redis cluster怎么做到高可用的？</h3><h3 id="32-raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？"><a href="#32-raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？" class="headerlink" title="32. raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？"></a>32. raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？</h3><h3 id="33-paxos和zookeeper的zab算法，他们之前有啥区别？"><a href="#33-paxos和zookeeper的zab算法，他们之前有啥区别？" class="headerlink" title="33. paxos和zookeeper的zab算法，他们之前有啥区别？"></a>33. paxos和zookeeper的zab算法，他们之前有啥区别？</h3><h3 id="34-删除链表的倒数第-N-个节点"><a href="#34-删除链表的倒数第-N-个节点" class="headerlink" title="34. 删除链表的倒数第 N 个节点"></a>34. 删除链表的倒数第 N 个节点</h3><p>双指针，first 第一次先移动N个节点，second移动一个节点，之后first和second都移动一个节点，直到first.next&#x3D;null，删除second对应的节点</p>
<h3 id="35-树"><a href="#35-树" class="headerlink" title="35. 树"></a>35. 树</h3><p>B-(B)树 多路搜索树<br>b+树在b树基础上，叶子结点增加链表指针，非叶子结点是叶子节点的索引<br>b*树在b+树基础上，非叶子结点也增加链表指针</p>
<p>二叉树最坏情况会变成线性结构，时间是O(n)。avl 二叉平衡树要求左右子树的最大高度不超过1，通过自旋来保证结构，从而保证时间是O(logn)<br>红黑树属于不严格的avl，不严格指的是不用严格去控制高度，这就保证了插入效率的提高。而查找的话，由于avl更平衡，所以avl的效率要比红黑树平均要高。红黑树算是空间换时间</p>
<p>B+树更适合做数据库索引的原因：磁盘读写代价更低，b树所有节点都有数据，导致要查找的时候一页数据更少；b+树的查询效率更稳定，任何查询都需要从根走到叶子<br>B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。<br>B+树的缺点：会产生大量的随机IO。原因是随着数据的插入，逻辑上连续的叶子节点往往会在物理上不连续，无法甚至分隔很远，导致在做范围查询的时候，会产生大量的随机IO &#x3D;&gt; 主要是由于数据全在磁盘，如果数据相距很远，磁盘寻址很慢</p>
<p>LSM树（Log-Structured Merge-Trees）：把一颗大树拆分成n棵小树，先写入内存，在内存中构建一颗有序的小树，在到达一定大小后刷到磁盘。读数据的时候，由于不知道数据在哪棵小树，所以需要遍历所有的小树，每棵小树都是有序的 &#x3D;&gt; 牺牲了部分读性能，大幅提高写性能<br>由此推到HBase的一些概念：</p>
<ul>
<li>WAL：为了避免因为断电导致内存中的数据会丢失，所以先在磁盘上记录logfile，然后写到内存中，当数据刷到磁盘后，logfile就可以删除了</li>
<li>memstore、storeFile：内存中的小树就是memstore，每次flush，内存中的memstore就会变成磁盘上的storeFile</li>
<li>compact：小树过多，会影响到读的性能，所以需要不定时合并小树</li>
</ul>
<blockquote>
<p>hbase 使用跳表来保证内存memstore中key是有序的<br>MemTable 是内存中的数据结构，当MemTable到一定大小后，会转化成Immutable MemTable，这是将 MemTable 转成 SSTable 的一种中间状态。写操作会由新的 MemTable 处理。<br>SSTable 是有序键值对集合，是LSM树在磁盘中的数据结构，为了加快读取，可以建立索引以及布隆过滤器来加快key的查找</p>
</blockquote>
<h3 id="36-mysql-的索引"><a href="#36-mysql-的索引" class="headerlink" title="36. mysql 的索引"></a>36. mysql 的索引</h3><p>innoBD 引擎，主键是聚簇索引，如果不指定主键，将第一个列都是not null的唯一索引作为聚簇索引；每个innnoDB<strong>有且仅有</strong>有一个聚簇索引<br>再创建的都是非聚簇索引，在叶子节点会记录主键的值，然后指向聚簇索引的叶子节点<br>整个过程从K索引树到主键索引树的过程叫做<strong>回表</strong></p>
<blockquote>
<p>主索引（聚簇索引）叶子节点会保存整条数据，辅助索引（非聚簇索引）会保存指定的列+主键的数据，如果查询的时候列大于辅助索引中的列，那么就会根据查询到的id去主索引里继续查，也就是回表</p>
</blockquote>
<p><img src="https://images.weserv.nl/?url=https://img3.sycdn.imooc.com/5d24c29b0001590909470341.jpg"></p>
<h3 id="37-处理海量数据思路"><a href="#37-处理海量数据思路" class="headerlink" title="37. 处理海量数据思路"></a>37. 处理海量数据思路</h3><ol>
<li>分而治之&#x2F;hash映射 + hash统计 + 堆&#x2F;快速&#x2F;归并排序</li>
<li>双层桶划分</li>
<li>Bloom filter&#x2F;Bitmap</li>
<li>Trie树&#x2F;数据库&#x2F;倒排索引</li>
<li>外排序</li>
<li>分布式处理之Hadoop&#x2F;Mapreduce</li>
</ol>
<h3 id="38-一个线程死循环，另一个线程还能不能执行"><a href="#38-一个线程死循环，另一个线程还能不能执行" class="headerlink" title="38. 一个线程死循环，另一个线程还能不能执行"></a>38. 一个线程死循环，另一个线程还能不能执行</h3><p>要看死循环的线程占用的是什么锁，如果是自己的锁，那没事，另一个线程还可以被执行到；但如果两个线程占用的是同一个对象的锁，一个死循环，那另一个就执行不了</p>
<h3 id="39-Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"><a href="#39-Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么" class="headerlink" title="39. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"></a>39. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</h3><p>ISR:In-Sync Replicas 副本同步队列<br>AR:Assigned Replicas 所有副本<br>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR。</p>
<h3 id="40-Yarn的调度方式"><a href="#40-Yarn的调度方式" class="headerlink" title="40. Yarn的调度方式"></a>40. Yarn的调度方式</h3><ol>
<li>先进先出<ul>
<li>有可能会导致大量的小作业得不到执行</li>
</ul>
</li>
<li>容器<ul>
<li>先划分一部分资源看做一个容器，专门用来运行小作业，缺点就是为小任务专门设置一个队列会预先占用一定的集群资源，这就导致大任务的执行时间会落后于使用FIFO调度器时的时间</li>
</ul>
</li>
<li>公平<ul>
<li>只有一个job的时候，占用所有的资源；提交第二个job，会平分资源，使两个job共享集群资源</li>
</ul>
</li>
</ol>
<h3 id="41-kafka-的数据积压"><a href="#41-kafka-的数据积压" class="headerlink" title="41. kafka 的数据积压"></a>41. kafka 的数据积压</h3><p>积压就是生产者速度 &gt; 消费者速度<br>解决思路：</p>
<ol>
<li>重启作业从上一次提交的offset开始重新执行</li>
<li>有可能是因为partition不够，导致数据过于集中，那么可以尝试增多partiton</li>
<li>减少每一次batch的数据量大小，略微提高获取batch的频率，勤拿少取</li>
<li>有可能存在数据倾斜，单纯是数据其中在某些partition里，那么就尝试在key前面加上随机数，打散数据</li>
</ol>
<h3 id="42-在hbase表中插入大量数据"><a href="#42-在hbase表中插入大量数据" class="headerlink" title="42. 在hbase表中插入大量数据"></a>42. 在hbase表中插入大量数据</h3><p>Region会不断增大，不停的split，会影响效率 &#x3D;&gt; 进行分区，控制region的个数 &#x3D;&gt; split 或者 加盐</p>
<h3 id="43-hive-中的-union和union-all"><a href="#43-hive-中的-union和union-all" class="headerlink" title="43. hive 中的 union和union all"></a>43. hive 中的 union和union all</h3><p>union 是 union distinct 的缩写，使用 union 的话会对select出来的列中的重复值进行<strong>去重并排序</strong></p>
<p>union all 就是单纯把列的结果合并在一起，不去重不排序</p>
<h3 id="44-十台机器同时去执行一条命令"><a href="#44-十台机器同时去执行一条命令" class="headerlink" title="44. 十台机器同时去执行一条命令"></a>44. 十台机器同时去执行一条命令</h3><p>list.txt 中去写入一些机器的ip</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in `cat ./allhosts`; do echo $i; ssh $i &quot;service ntpd restart&quot;;done</span><br></pre></td></tr></table></figure>

<h3 id="45-flink中的-dataset-和-datastream"><a href="#45-flink中的-dataset-和-datastream" class="headerlink" title="45. flink中的 dataset 和 datastream"></a>45. flink中的 dataset 和 datastream</h3><ul>
<li>dataset 中的 source 来源于文件、表或者 Java 集合</li>
<li>datastream 中的 source 一般是消息中间件比如 Kafka</li>
</ul>
<h3 id="46-咆哮位图"><a href="#46-咆哮位图" class="headerlink" title="46. 咆哮位图"></a>46. 咆哮位图</h3><p>N&#x2F;65536 &#x3D; block_id<br>N%65536 &#x3D; 在对应的block内的一个偏移量</p>
<p>将位图分block，每一个值都放到对应的block的位置上</p>
<h3 id="47-HDFS-小文件"><a href="#47-HDFS-小文件" class="headerlink" title="47. HDFS 小文件"></a>47. HDFS 小文件</h3><ol>
<li>如果是hive的话</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive.merge.mapfiles</span><br><span class="line">hive.merge.mapredfiles</span><br><span class="line">hive.merge.size.per.task</span><br><span class="line">hive.merge.smallfiles.avgsize</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果是已有的小文件</li>
</ol>
<p>Hadoop 自带三个方案，Hadoop Archive，Sequence file和CombineFileInputFormat。</p>
<ul>
<li>Hadoop Archive：主要是用来归档，如果其中小文件出现问题，需要重新归档，因为中间涉及到索引信息的更改等；另外如果作为mr的输入路径，那么还是一个小文件对应一个map</li>
<li>Sequence file：可以做压缩；支持splitable，那么就可以作为mr的输入；但是需要自己编写程序来实现，另外由于是二进制文件，不方便查看</li>
<li>CombineFile：也是基于mr来进行转换，如果要合并的小文件很多，那么最终合并的文件会包含过多的额外信息，浪费过多的空间，所以这种方案目前相对用得比较少</li>
</ul>
<h3 id="48-flink-数据积压"><a href="#48-flink-数据积压" class="headerlink" title="48. flink 数据积压"></a>48. flink 数据积压</h3><h3 id="49-hive参数调优"><a href="#49-hive参数调优" class="headerlink" title="49. hive参数调优"></a>49. hive参数调优</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.parrallel=true; # 针对类似union all这样的，操作相互不关联的情况，可以设置并行度</span><br><span class="line">set hive.exec.parallel.thread.number=8; # 并行度的个数</span><br><span class="line"></span><br><span class="line">set hive.map.aggr=true; # 在map端进行聚合</span><br><span class="line">set hive.groupby.mapaggr.checkinterval=100000; # 在map端进行聚合操作的数据条数</span><br><span class="line"></span><br><span class="line"># 在数据分布不均时，即发生倾斜时进行负载均衡，可以进行如下的参数设置</span><br><span class="line">set hive.groupby.skewindata=true; # 生成的查询计划会有两个MR Job。第一个MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key有可能被分发到不同的Reduce 中，从而达到负载衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中，最后完成最终的聚合操作 # 类似于mapreduce中加一个combine</span><br><span class="line"></span><br><span class="line"># join出现数据倾斜时，需要设置参数</span><br><span class="line">set hive.skewjoin.key=10000; # 这个是join的键对应的记录条数超过这个值则会进行分拆</span><br><span class="line">set hive.optimize.skewjoin=true; # 如果是join 过程出现倾斜 应该设置为true</span><br><span class="line"></span><br><span class="line">set mapred.max.split.size=xx; # map前合并小文件</span><br><span class="line">set hive.merge.mapfiles=true; # map结束后合并小文件</span><br><span class="line">set hive.merge.mapredfiles=true; # 合并reduce输出文件</span><br></pre></td></tr></table></figure>

<h3 id="50-NameNode-单点故障"><a href="#50-NameNode-单点故障" class="headerlink" title="50. NameNode 单点故障"></a>50. NameNode 单点故障</h3><blockquote>
<p>HDFS1 是一个namenode，一个secondarynamenode，元数据放在内存里，会出现单点问题和内存受限问题</p>
</blockquote>
<p>两个NameNode，会去竞争ZK中的一把锁，谁抢到了谁就是active节点，类似于kafka的controller和follower，controller主要是为了同步元数据，然后follower去同步，所以kafka每一个broker都会有元数据</p>
<p>每个NameNode都有一个进程 ZKFC，会向zk汇报心跳情况，如果挂了之后，会自动做切换<br>HDFS的元数据会单独去建一个集群，里面会有2N+1个节点，叫 journalNode，它们会保存元数据信息，能保证这些 journalNode 里的数据都是一样的。<br>Active NameNode 往 journalnode 写元数据，Standby NameNode 从 journalnode 读元数据同步</p>
<h3 id="51-presto-kylin"><a href="#51-presto-kylin" class="headerlink" title="51. presto &amp; kylin"></a>51. presto &amp; kylin</h3><ul>
<li>presto<br>  主要的处理都在内存中，拿一部分数据放内存计算，计算完之后，再拿下一部分数据<br>  如果涉及到多表关联的话，可能内存吃不消</li>
<li>kylin<br>  核心是Cube，cube是一种预计算技术，基本思路是预先对数据作多维索引，查询时只扫描索引而不访问原始数据从而提速。<br>  如果要查询的条件变化太多，没有命中，就会导致计算非常慢；同时导入数据后会需要重新去做cube</li>
</ul>
<h3 id="52-HiveSql报错"><a href="#52-HiveSql报错" class="headerlink" title="52. HiveSql报错"></a>52. HiveSql报错</h3><p>MapReduce<br>FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask</p>
<p>修改hive依赖的hdfs参数：<br>dfs.client.block.write.locateFollowingBlock.retries  &#x3D;  8<br>dfs.client.block.write.retries  &#x3D; 8<br>dfs.client.cached.conn.retry &#x3D; 5</p>
<p>Hive on Spark<br>FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.spark.SparkTask<br>和上面一样，可能最底层的报错原因都是：Unable to close file because the last block does not have enough number of replicas。这说明了在某一时刻可能有任务大量读取blocks，耗费了过多的资源。</p>
<p>解决：</p>
<ol>
<li>排查出读取blocks过多的任务，对该任务进行优化调整，缩短读取的时间范围或通过中间表的形式进行查询，尽可能的不要一次读取过多blocks。</li>
<li>修改hive的参数 同上</li>
</ol>
<p>异常日志定位<br>1、查看Hiveserver2 日志， 使用 return code 找到出现该异常日志的线程编号<br>2、基于线程编号以关键字  Thread-28017]: Running with YARN Application 找到 applicationid<br>3、使用yarn logs -applicationId xx 获取到任务的所有日志信息<br>4、基于关键字 YarnAllocator: Driver requested 找到 spark 任务的 driver<br>5、在driver 日志中用关键字 ERROR， 寻找异常信息， 定位出异常的executor<br>6、找到executor 后， 基本就能找到出错原因</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Interview/" rel="tag"># Interview</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/13/DW/" rel="prev" title="数仓架构">
      <i class="fa fa-chevron-left"></i> 数仓架构
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/19/Linux-3/" rel="next" title="Linux 常用命令">
      Linux 常用命令 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Interview-1"><span class="nav-number">1.</span> <span class="nav-text">Interview-1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.</span> <span class="nav-text">1. 线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%AD%BB%E9%94%81%E7%9A%84%E7%8E%B0%E8%B1%A1%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">2. 死锁的现象和解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-ConcurrentHashMap-%E7%9A%84%E6%95%B0%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">3. ConcurrentHashMap 的数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-cas"><span class="nav-number">1.4.</span> <span class="nav-text">4. cas</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-concurrentHashMap-1-7-%E5%92%8C-1-8-%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">5. concurrentHashMap 1.7 和 1.8 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%A6%82%E4%BD%95%E5%9C%A8%E5%BE%88%E7%9F%AD%E7%9A%84%E6%97%B6%E9%97%B4%E5%86%85%E5%B0%86%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E5%88%B0ConcurrentHashMap-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98concurrentHashMap%E7%9A%84%E6%8F%92%E5%85%A5%E6%95%88%E7%8E%87"><span class="nav-number">1.6.</span> <span class="nav-text">6. 如何在很短的时间内将大量数据插入到ConcurrentHashMap &#x2F; 如何提高concurrentHashMap的插入效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-number">1.7.</span> <span class="nav-text">7. 线程池对工作线程的回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB"><span class="nav-number">1.8.</span> <span class="nav-text">8. 数据库的脏读、不可重复读和幻读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-TCP%E5%92%8CUDP"><span class="nav-number">1.9.</span> <span class="nav-text">9. TCP和UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-BIO%E3%80%81NIO%E3%80%81AIO-select-poll%E3%80%81epoll"><span class="nav-number">1.10.</span> <span class="nav-text">10. BIO、NIO、AIO &amp; select&#x2F;poll、epoll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-linux%E4%B8%8B%E7%9A%84java%E8%BF%9B%E7%A8%8B%E5%92%8Clinux%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%B8%80%E4%B8%80%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%B3%E7%B3%BB%E5%90%97"><span class="nav-number">1.11.</span> <span class="nav-text">11. linux下的java进程和linux线程有一一对应的关系吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-JVM-%E5%93%AA%E4%B8%80%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E7%8B%AC%E5%8D%A0%E5%93%AA%E4%B8%80%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="nav-number">1.12.</span> <span class="nav-text">12. JVM 哪一些是线程独占哪一些是线程共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-JDK8-%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4"><span class="nav-number">1.13.</span> <span class="nav-text">13. JDK8 永久代和元空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Linux-%E5%88%86%E6%AE%B5"><span class="nav-number">1.14.</span> <span class="nav-text">14. Linux 分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.15.</span> <span class="nav-text">15. 抽象类和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-synchronized-%E5%92%8C-ReentrantLock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.16.</span> <span class="nav-text">16. synchronized 和 ReentrantLock的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E6%80%8E%E4%B9%88%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.17.</span> <span class="nav-text">17. 怎么唤醒一个阻塞的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86int%E8%BF%98%E8%A6%81%E6%9C%89%E8%AE%BE%E8%AE%A1Integer"><span class="nav-number">1.18.</span> <span class="nav-text">18. int和Integer的区别，为什么有了int还要有设计Integer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Executor%E5%B0%81%E8%A3%85%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.19.</span> <span class="nav-text">19. Executor封装的四种线程池类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F"><span class="nav-number">1.20.</span> <span class="nav-text">20. 线程池为什么要使用阻塞队列而不使用非阻塞队列？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1"><span class="nav-number">1.21.</span> <span class="nav-text">21. 常用的并发工具类有哪些？线程之间的互相通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-volatile"><span class="nav-number">1.22.</span> <span class="nav-text">22. volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-AQS"><span class="nav-number">1.23.</span> <span class="nav-text">23. AQS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-synchronized-%E4%B8%AD%E7%9A%84%E9%94%81%E6%B1%A0%E5%92%8C%E7%AD%89%E5%BE%85%E6%B1%A0"><span class="nav-number">1.24.</span> <span class="nav-text">24. synchronized 中的锁池和等待池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#24-1-wait-%E6%96%B9%E6%B3%95%E5%A4%96%E9%9D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFwhile%E5%BE%AA%E7%8E%AF%E8%80%8C%E4%B8%8D%E6%98%AFif%E5%88%A4%E6%96%AD"><span class="nav-number">1.24.1.</span> <span class="nav-text">24.1 wait()方法外面为什么是while循环而不是if判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8notifyAll-%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%A8notify-%E8%A1%8C%E5%90%97"><span class="nav-number">1.24.2.</span> <span class="nav-text">24.2 为什么要用notifyAll()方法，用notify()行吗</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-sleep-%E5%92%8C-wait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.25.</span> <span class="nav-text">25. sleep 和 wait 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E7%BA%BF%E7%A8%8B%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E5%9D%97%E6%98%AF%E8%A2%AB%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84"><span class="nav-number">1.26.</span> <span class="nav-text">26. 线程类的构造方法、静态块是被哪个线程调用的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.27.</span> <span class="nav-text">27. 设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-Redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.28.</span> <span class="nav-text">28. Redis 线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%9B%9E%E5%86%99Redis-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">1.29.</span> <span class="nav-text">30. 并发修改数据库并回写Redis 如何保证数据一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-redis%E7%9A%84hash%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8Crehash%E8%BF%87%E7%A8%8B%E8%AE%B2%E4%B8%80%E4%B8%8B-%E5%92%8CJavaHashMap%E7%9A%84rehash%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9Fredis-cluster%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">1.30.</span> <span class="nav-text">31. redis的hash怎么实现的，rehash过程讲一下 和JavaHashMap的rehash有什么区别？redis cluster怎么做到高可用的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-raft%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%EF%BC%9Fraft%E7%AE%97%E6%B3%95%E9%87%8C%E9%9D%A2%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E8%84%91%E8%A3%82%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">1.31.</span> <span class="nav-text">32. raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-paxos%E5%92%8Czookeeper%E7%9A%84zab%E7%AE%97%E6%B3%95%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E5%89%8D%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.32.</span> <span class="nav-text">33. paxos和zookeeper的zab算法，他们之前有啥区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">1.33.</span> <span class="nav-text">34. 删除链表的倒数第 N 个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-%E6%A0%91"><span class="nav-number">1.34.</span> <span class="nav-text">35. 树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-mysql-%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">1.35.</span> <span class="nav-text">36. mysql 的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-%E5%A4%84%E7%90%86%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%80%9D%E8%B7%AF"><span class="nav-number">1.36.</span> <span class="nav-text">37. 处理海量数据思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%98%E8%83%BD%E4%B8%8D%E8%83%BD%E6%89%A7%E8%A1%8C"><span class="nav-number">1.37.</span> <span class="nav-text">38. 一个线程死循环，另一个线程还能不能执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Kafka%E4%B8%AD%E7%9A%84ISR%E3%80%81AR%E5%8F%88%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%EF%BC%9FISR%E7%9A%84%E4%BC%B8%E7%BC%A9%E5%8F%88%E6%8C%87%E4%BB%80%E4%B9%88"><span class="nav-number">1.38.</span> <span class="nav-text">39. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-Yarn%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="nav-number">1.39.</span> <span class="nav-text">40. Yarn的调度方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-kafka-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%A7%AF%E5%8E%8B"><span class="nav-number">1.40.</span> <span class="nav-text">41. kafka 的数据积压</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E5%9C%A8hbase%E8%A1%A8%E4%B8%AD%E6%8F%92%E5%85%A5%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">1.41.</span> <span class="nav-text">42. 在hbase表中插入大量数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-hive-%E4%B8%AD%E7%9A%84-union%E5%92%8Cunion-all"><span class="nav-number">1.42.</span> <span class="nav-text">43. hive 中的 union和union all</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E5%8D%81%E5%8F%B0%E6%9C%BA%E5%99%A8%E5%90%8C%E6%97%B6%E5%8E%BB%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E5%91%BD%E4%BB%A4"><span class="nav-number">1.43.</span> <span class="nav-text">44. 十台机器同时去执行一条命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-flink%E4%B8%AD%E7%9A%84-dataset-%E5%92%8C-datastream"><span class="nav-number">1.44.</span> <span class="nav-text">45. flink中的 dataset 和 datastream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-%E5%92%86%E5%93%AE%E4%BD%8D%E5%9B%BE"><span class="nav-number">1.45.</span> <span class="nav-text">46. 咆哮位图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-HDFS-%E5%B0%8F%E6%96%87%E4%BB%B6"><span class="nav-number">1.46.</span> <span class="nav-text">47. HDFS 小文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-flink-%E6%95%B0%E6%8D%AE%E7%A7%AF%E5%8E%8B"><span class="nav-number">1.47.</span> <span class="nav-text">48. flink 数据积压</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-hive%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="nav-number">1.48.</span> <span class="nav-text">49. hive参数调优</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-NameNode-%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C"><span class="nav-number">1.49.</span> <span class="nav-text">50. NameNode 单点故障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-presto-kylin"><span class="nav-number">1.50.</span> <span class="nav-text">51. presto &amp; kylin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#52-HiveSql%E6%8A%A5%E9%94%99"><span class="nav-number">1.51.</span> <span class="nav-text">52. HiveSql报错</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mxxct"
      src="/images/panda-180.png">
  <p class="site-author-name" itemprop="name">Mxxct</p>
  <div class="site-description" itemprop="description">君子不器</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mxxt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mxxt" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:386965035@qq.com" title="邮箱 → mailto:386965035@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>邮箱</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mxxct</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">617k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:21</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'FeVPpNOBXhL1P240cNkmAKc3-gzGzoHsz',
      appKey     : 'TJ9vKn2xQ16geSxRr80seK0S',
      placeholder: "来说点什么吧~~~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
