<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/panda-180-3.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/panda-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/panda-16.png">
  <link rel="mask-icon" href="/images/panda.svg" color="#222">
  <meta name="baidu-site-verification" content="m1ei8mEvXD">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mxxct4git.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"default"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="君子不器">
<meta property="og:type" content="website">
<meta property="og:title" content="猫熊小才天の书院">
<meta property="og:url" content="https://mxxct4git.github.io/index.html">
<meta property="og:site_name" content="猫熊小才天の书院">
<meta property="og:description" content="君子不器">
<meta property="og:locale">
<meta property="article:author" content="Mxxct">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mxxct4git.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>猫熊小才天の书院</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">猫熊小才天の书院</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mxxct4git.github.io/2022/03/15/ck-2%20%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda-180.png">
      <meta itemprop="name" content="Mxxct">
      <meta itemprop="description" content="君子不器">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫熊小才天の书院">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/15/ck-2%20%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">ClickHouse笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-15 11:09:28 / Modified: 15:23:13" itemprop="dateCreated datePublished" datetime="2022-03-15T11:09:28+08:00">2022-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ClickHouse/" itemprop="url" rel="index"><span itemprop="name">ClickHouse</span></a>
                </span>
            </span>

          
            <span id="/2022/03/15/ck-2%20%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="ClickHouse笔记" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/03/15/ck-2%20%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/03/15/ck-2%20%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ClickHouse"><a href="#ClickHouse" class="headerlink" title="ClickHouse"></a>ClickHouse</h2><p><a href="https://zhuanlan.zhihu.com/p/98135840">ClickHouse深度揭秘</a></p>
<p>开源列式数据库，针对 OLAP 领域</p>
<p>es 是搜索引擎，主要用于搜索，附带聚合能力</p>
<p>ck 是数据库，主要是crud，聚合查询是强项。数据库一般不具备模糊搜索的能力，或者说模糊搜索能力相对较差</p>
<h3 id="1-OLAP-场景的特点"><a href="#1-OLAP-场景的特点" class="headerlink" title="1. OLAP 场景的特点"></a>1. OLAP 场景的特点</h3><ol>
<li>读多于写</li>
</ol>
<p>OLTP 事务处理，比如购物车、下单、支付等需要在原地进行大量增删改</p>
<p>OLAP 分析处理，通常是批量导入数据后，进行任意维度的读</p>
<ol>
<li>大宽表，读大量行但是少量列，结果集较小</li>
</ol>
<p>OLAP 场景下，通常有多张大宽表，列数非常多，通常会扫描大量行数据，只用到其中的某几列</p>
<ol>
<li>数据批量写入，且数据不更新或少更新</li>
</ol>
<p>OLTP类业务对于延时（Latency）要求更高，要避免让客户等待造成业务损失；而OLAP类业务，由于数据量非常大，通常更加关注写入吞吐（Throughput），要求海量数据能够尽快导入完成。一旦导入完成，历史数据往往作为存档，不会再做更新、删除操作。</p>
<ol>
<li>无需事务，数据一致性要求低</li>
</ol>
<p>OLAP类业务对于事务需求较少，通常是导入历史日志数据，或搭配一款事务型数据库并实时从事务型数据库中进行数据同步。多数OLAP系统都支持最终一致性。</p>
<ol>
<li>灵活多变，不适合预先建模</li>
</ol>
<p>分析场景下，随着业务变化要及时调整分析维度、挖掘方法，以尽快发现数据价值、更新业务指标。而数据仓库中通常存储着海量的历史数据，调整代价十分高昂。预先建模技术虽然可以在特定场景中加速计算，但是无法满足业务灵活多变的发展需求，维护成本过高。</p>
<h3 id="2-ClickHouse-存储层"><a href="#2-ClickHouse-存储层" class="headerlink" title="2. ClickHouse 存储层"></a>2. ClickHouse 存储层</h3><ol>
<li><p>列式存储</p>
</li>
<li><p>数据有序存储</p>
<p>在建表时，指定将数据按照某些列进行排序。排序后保证了数据在磁盘上连续存储，有序摆放。在进行等值、范围查找时，where命中的数据会在邻近的block中，减少了io。</p>
<p>进来一批数据就要重新来一次排序，所以数据进来不更新或少更新</p>
</li>
<li><p>主键索引</p>
<p>类似于hbase按照rowkey来划分range，每一个range的第一行作为mark，查询的时候可以根据mark行的值来快速过滤</p>
</li>
<li><p>稀疏索引</p>
<p>？？？</p>
</li>
<li><p>数据分片</p>
<p>集群模式可以把数据分散存储在不同的节点。比如有随机分片、固定分片、按某一列进行hash分片等等</p>
</li>
<li><p>数据分区</p>
<p>可以将数据根据业务随意分区，这样在查询的时候可以只过滤出需要的数据加快查询，另外可以针对特殊分区来单独进行TTL管理，淘汰过期的分区数据</p>
</li>
<li><p>数据TTl</p>
<p>提供行级别、列级别、分区级别的TTL，其中列级别的TTL会在一列中部分数据过期后，被替换成默认值，当一列所有数据都过期后，删除整列</p>
</li>
<li><p>高吞吐写入能力</p>
<p>采用LSM Tree方式</p>
</li>
<li><p>有限支持 delete、update</p>
<p>在 OLAP 分析场景中，删除、更新并不是核心需求，所以并没有直接提供 delete、update 等操作，而是变相支持 mutation 操作，限制了删除、更新为异步操作，只有当后台合并之后才能生效</p>
</li>
<li><p>主备同步</p>
</li>
</ol>
<h3 id="3-ClickHouse-计算层"><a href="#3-ClickHouse-计算层" class="headerlink" title="3. ClickHouse 计算层"></a>3. ClickHouse 计算层</h3><ol>
<li><p>多核并行</p>
<p>数据分片，也就是分区，每一个分区的数据再按行键分成好几个组，这样可以并行处理多组数据</p>
</li>
<li><p>分布式计算</p>
<p>自动把查询拆解到多个task下发到集群中，然后进行多机并行处理，最后把结果汇聚到一起。</p>
</li>
<li><p>向量化执行与SIMD</p>
<p>按列存储，按列计算，每一列的每一个batch调用一次SMID指令（而非每一行调用一次），不禁减少函数调用次数，提高了cpu在读取数据时缓存命中率（如果内存中按列存储，但是计算按行处理，无法充分利用cpu cache的预读能力，造成cpu cache miss严重），提高SMID指令的并行执行能力，大幅缩短计算耗时。</p>
</li>
<li><p>动态代码生成 Runtime Codegen</p>
<p>实现基于 Expression 级别的动态代码生成，消除了大量虚函数的调用，由于运行时表达式的参数类型、个数都是已知的，消除了不必要的if-else分支判断</p>
</li>
<li><p>近似计算</p>
<p>以损失一定结果精度为代价，极大地提升查询性能。</p>
<ul>
<li>近似估算distinct values、中位数，分位数等多种聚合函数；</li>
</ul>
</li>
</ol>
<ul>
<li>建表DDL支持SAMPLE BY子句，支持对于数据进行抽样处理；</li>
</ul>
<ol>
<li>复杂数据类型支持</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mxxct4git.github.io/2022/01/18/ck-1%20%E7%AC%94%E8%AE%B0-%E5%B0%9A%E7%A1%85%E8%B0%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda-180.png">
      <meta itemprop="name" content="Mxxct">
      <meta itemprop="description" content="君子不器">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫熊小才天の书院">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/18/ck-1%20%E7%AC%94%E8%AE%B0-%E5%B0%9A%E7%A1%85%E8%B0%B7/" class="post-title-link" itemprop="url">ClickHouse笔记-尚硅谷</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-18 11:09:28" itemprop="dateCreated datePublished" datetime="2022-01-18T11:09:28+08:00">2022-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ClickHouse/" itemprop="url" rel="index"><span itemprop="name">ClickHouse</span></a>
                </span>
            </span>

          
            <span id="/2022/01/18/ck-1%20%E7%AC%94%E8%AE%B0-%E5%B0%9A%E7%A1%85%E8%B0%B7/" class="post-meta-item leancloud_visitors" data-flag-title="ClickHouse笔记-尚硅谷" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2022/01/18/ck-1%20%E7%AC%94%E8%AE%B0-%E5%B0%9A%E7%A1%85%E8%B0%B7/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2022/01/18/ck-1%20%E7%AC%94%E8%AE%B0-%E5%B0%9A%E7%A1%85%E8%B0%B7/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="ClickHouse笔记-尚硅谷"><a href="#ClickHouse笔记-尚硅谷" class="headerlink" title="ClickHouse笔记-尚硅谷"></a>ClickHouse笔记-尚硅谷</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h3><h4 id="1-1-整型"><a href="#1-1-整型" class="headerlink" title="1.1 整型"></a>1.1 整型</h4><blockquote>
<p>  后面的数字都是表示位数，bit 位数</p>
</blockquote>
<ul>
<li>有符号<ul>
<li>Int8: 范围 [-128, 127]，对应 Java 里的 byte</li>
<li>Int16: 范围 [-32768, 32767] 对应 Java 里的 short</li>
<li>Int32: 范围 [-2147483648, 2147483647] 4个字节，对应 Java 里的 int</li>
<li>Int64: 8 个字节，对应 Java 里的 long</li>
</ul>
</li>
<li>无符号<ul>
<li>UInt8: 范围 [0, 255]</li>
<li>UInt16: 范围 [0, 65535]</li>
<li>UInt32: 范围 [0, 4294967295]</li>
<li>UInt64</li>
</ul>
</li>
</ul>
<h4 id="1-2-浮点型"><a href="#1-2-浮点型" class="headerlink" title="1.2 浮点型"></a>1.2 浮点型</h4><p>Float32: 4 个字节，对应 Java 里的 float Float64: 8 个字节，对应 Java 里的 double</p>
<blockquote>
<p>  浮点型存在精度丢失，使用 Decimal 存储</p>
</blockquote>
<h4 id="1-3-布尔型"><a href="#1-3-布尔型" class="headerlink" title="1.3 布尔型"></a>1.3 布尔型</h4><p>没有 true 和 false，一般使用 UInt8 来存储，取值限制 0 或 1</p>
<h4 id="1-4-Decimal"><a href="#1-4-Decimal" class="headerlink" title="1.4 Decimal"></a>1.4 Decimal</h4><p>不会四舍五入，用来保持精度，三种声明方式</p>
<ul>
<li>Decimal32(s): 相当于 Decimal(9-s, s)，有效位数为 1–9</li>
<li>Decimal64(s): 相当于 Decimal(18-s, s)，有效位数为 1–18</li>
<li>Decimal128(s): 相当于 Decimal(38-s, s)，有效位数为 1–38</li>
</ul>
<p>这里的 s 需要声明时指定，指的是小数部分保留几位</p>
<h4 id="1-5-字符串"><a href="#1-5-字符串" class="headerlink" title="1.5 字符串"></a>1.5 字符串</h4><ul>
<li>String: 任意长度，包括空字节</li>
<li>FixedString(N): 固定长度 N 的字符串，会在字符串末尾添加空字节来达到 N 字节长度。当读取到长度大于 N 的字符串的时候，会报错</li>
</ul>
<h4 id="1-6-枚举类型"><a href="#1-6-枚举类型" class="headerlink" title="1.6 枚举类型"></a>1.6 枚举类型</h4><p>包括 Enum8 和 Enum16，其中 Enum8 存的是 ‘String’ 和 Integer 的映射关系，Enum16 存的是 ‘String’ 和 ‘String’ 的映射关系</p>
<p>是一种空间上的优化，但是如果插入的数据不在设置的枚举值里面的话，会插入不进去，导致数据丢失</p>
<h4 id="1-7-时间类型"><a href="#1-7-时间类型" class="headerlink" title="1.7 时间类型"></a>1.7 时间类型</h4><ul>
<li>Date: 接受 yyyy-MM-dd 的字符串</li>
<li>DateTime: 接受 yyyy-MM-dd HH:mm:ss 的字符串</li>
<li>DateTime64: 接受 yyyy-MM-dd HH:mm:ss.S 是字符串</li>
</ul>
<h4 id="1-8-数组类型"><a href="#1-8-数组类型" class="headerlink" title="1.8 数组类型"></a>1.8 数组类型</h4><p>Array(T) 其中 T 可以是任意类型，但是不推荐使用多维数组。</p>
<blockquote>
<p>  不能在 MergeTree 表中存储多维数组</p>
</blockquote>
<h3 id="2-建表语句"><a href="#2-建表语句" class="headerlink" title="2. 建表语句"></a>2. 建表语句</h3><h4 id="2-1-primary-key"><a href="#2-1-primary-key" class="headerlink" title="2.1 primary key"></a>2.1 primary key</h4><p>可选项，可以不指定</p>
<p>只提供数据的一级索引，<strong>不提供唯一约束</strong>，即可以出现相同 primary key 的数据</p>
<p>主键的设计主要依据查询 sql 中 where 条件</p>
<p>由于主键索引是稀疏索引，可以类比于跳表，根据指定的 index granularity（索引粒度）来进行快速查找。默认是 8192，基本上不需要修改这个值，除非主键会存在大量重复的值，几万行数据才会出现一个不同的主键值</p>
<h4 id="2-2-partition-by"><a href="#2-2-partition-by" class="headerlink" title="2.2 partition by"></a>2.2 partition by</h4><p>可选项，可以不指定</p>
<p>如果不指定分区的话，默认数据都在 all 分区下。</p>
<p>分区就是分目录保存，里面有 列文件 + 索引文件 + 表定义文件 + 校验文件 等等</p>
<ul>
<li>bin 文件：数据文件</li>
<li>mrk 文件：标记文件<ul>
<li>标记文件在 idx索引文件和 bin数据文件之间起到了桥梁作用</li>
<li>以 mrk2 结尾的文件，表示该表启用了自适应索引间隔</li>
</ul>
</li>
<li>primary.idx 文件：主键索引文件</li>
<li>minmax.create_time.idx：分区键的最大最小值</li>
<li>checksums.txt：校验文件</li>
<li>count.txt：保存数据条数</li>
</ul>
<p>分区后，ck 会按照分区为单位进行并行处理</p>
<p>分区目录的命名规则如下: partitionID_MinBlockNum_MaxBlockNum_Level</p>
<ul>
<li>partitionID<ul>
<li>根据指定的分区字段生成</li>
</ul>
</li>
<li>MinBlockNum<ul>
<li>最小分区块的编号，每产生一个新的目录分区就会向上递增</li>
<li>如果向同一个分区去不断写数据，可能就会产生新的目录分区块，等待后台异步数据合并</li>
</ul>
</li>
<li>MaxBlockNum<ul>
<li>最大分区块的编号</li>
</ul>
</li>
<li>Level<ul>
<li>合并次数</li>
</ul>
</li>
</ul>
<h4 id="2-3-order-by"><a href="#2-3-order-by" class="headerlink" title="2.3 order by"></a>2.3 order by</h4><p>必选项</p>
<p>保证分区内数据按照指定字段有序保存 &lt;&#x3D;&#x3D;&#x3D;&gt; 由于要保证主键索引是生效的，那么有序排序是必须的，否则稀疏索引就不生效</p>
<p>主键必须是 order by 指定的字段，同时必须是按照顺序来的。比如 order by (id, name)，那么主键就必须是 id 或者 (id, name)，不能是 name</p>
<h4 id="2-4-二级索引"><a href="#2-4-二级索引" class="headerlink" title="2.4 二级索引"></a>2.4 二级索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> t_order(</span><br><span class="line">id UInt32,</span><br><span class="line">sku_id String,</span><br><span class="line">total_amount <span class="type">Decimal</span>(<span class="number">16</span>,<span class="number">2</span>),</span><br><span class="line">create_time DateTime,</span><br><span class="line">INDEX a total_amount Type minmax GRANULARITY <span class="number">5</span></span><br><span class="line">)engine <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">primary key</span> (id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id</span><br></pre></td></tr></table></figure>

<p>二级索引是在一级索引基础上创建的，GRANULARITY 的值就是二级索引对于一级索引粒度的粒度 &lt;&#x3D;&#x3D;&#x3D;&gt; 一级索引按照 8192 行数据当成一个块的话，那么 GRANULARITY 5 就是说每 5 块再做一次二级索引</p>
<p><code>INDEX 索引名字 指定字段 Type minmax GRANULARITY N</code> 其中主要用到的二级索引类型是 minmax</p>
<h4 id="2-5-TTL"><a href="#2-5-TTL" class="headerlink" title="2.5 TTL"></a>2.5 TTL</h4><p>支持某列或整张表的 TTL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> t_order(</span><br><span class="line">id UInt32,</span><br><span class="line">sku_id String,</span><br><span class="line">total_amount <span class="type">Decimal</span>(<span class="number">16</span>,<span class="number">2</span>) TTL create_time <span class="operator">+</span> <span class="type">interval</span> <span class="number">10</span> <span class="keyword">SECOND</span>,</span><br><span class="line">create_time DateTime</span><br><span class="line">)engine <span class="operator">=</span> MergeTree()</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">primary key</span> (id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id</span><br></pre></td></tr></table></figure>

<p>需要注意的是，基于某个字段（create_time）来设置过期，那么这个字段不能是主键，同时必须是日期类型</p>
<p>如果要修改已存在的表的列的 TTL 的话，可以通过下面的 sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> xxx MODIFY <span class="keyword">COLUMN</span> col String TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure>

<p>如果要修改表的 TTL 的话，可以通过下面的 sql</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> xxx MODIFY TTL create_time <span class="operator">+</span> <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-optimize"><a href="#2-6-optimize" class="headerlink" title="2.6 optimize"></a>2.6 optimize</h4><p>插入的数据会在后台异步合并，如果要手动触发的话，可以执行下面的命令，但是也不保证会立即执行，依旧是异步</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize <span class="keyword">table</span> xxx <span class="keyword">final</span></span><br></pre></td></tr></table></figure>

<p>同时可以指定某个分区进行合并</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize <span class="keyword">table</span> xxx <span class="keyword">partition</span> <span class="string">&#x27;20210925&#x27;</span> <span class="keyword">final</span></span><br></pre></td></tr></table></figure>

<h3 id="3-表引擎"><a href="#3-表引擎" class="headerlink" title="3. 表引擎"></a>3. 表引擎</h3><h4 id="3-1-TinyLog"><a href="#3-1-TinyLog" class="headerlink" title="3.1 TinyLog"></a>3.1 TinyLog</h4><p>以列文件的形式保存在磁盘上，不支持索引，没有并发控制，一般保存少量数据的小表</p>
<h4 id="3-2-Memory"><a href="#3-2-Memory" class="headerlink" title="3.2 Memory"></a>3.2 Memory</h4><p>内存引擎</p>
<h4 id="3-3-MergeTree"><a href="#3-3-MergeTree" class="headerlink" title="3.3 MergeTree"></a>3.3 MergeTree</h4><p>支持索引和分区</p>
<h4 id="3-3-1-ReplacingMergeTree"><a href="#3-3-1-ReplacingMergeTree" class="headerlink" title="3.3.1 ReplacingMergeTree"></a>3.3.1 ReplacingMergeTree</h4><p>增加去重功能。然而去重只会在合并的时候实现，合并的时间又是不确定的，所以会存在某些数据仍未被处理的情况</p>
<p>ReplacingMergeTree(c1) 可以指定按照某个列来进行判断，即按照 order by 指定的列进行去重时，按照 c1 取最大的那条数据，如果不指定的话，就按照插入顺序来去重保留</p>
<p>同时去重只在分区内去重，不能跨分区去重。所以可以理解为去重来节约存储空间，并不能解决数据重复问题。</p>
<p>如果说要跨分区来保证查询不重复，可以通过 argMax 函数来实现</p>
<h4 id="3-3-2-SummingMergeTree"><a href="#3-3-2-SummingMergeTree" class="headerlink" title="3.3.2 SummingMergeTree"></a>3.3.2 SummingMergeTree</h4><p>对于不查询明细，只关心以维度进行汇总聚合结果的场景。</p>
<p>SummingMergeTree(c1,c2) 指定的列必须是数字列，如果不填，会以所有非维度列（order by 指定的是维度列）且为数字列的字段进行聚合</p>
<p>只能在分区内聚合，并且只能在数据合并的时候进行聚合，所以在写 sql 的时候还是得写上 sum</p>
<h4 id="3-3-3-AggregationMergeTree"><a href="#3-3-3-AggregationMergeTree" class="headerlink" title="3.3.3 AggregationMergeTree"></a>3.3.3 AggregationMergeTree</h4><p>对比上面的sum，AggregationMergeTree 可以提供更多的聚合函数</p>
<h3 id="4-SQL-操作"><a href="#4-SQL-操作" class="headerlink" title="4. SQL 操作"></a>4. SQL 操作</h3><h4 id="4-1-Update-和-Delete"><a href="#4-1-Update-和-Delete" class="headerlink" title="4.1 Update 和 Delete"></a>4.1 Update 和 Delete</h4><p>不支持事务操作。通过 alter 来间接实现更新删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> xxx <span class="keyword">delete</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter table</span> xxx <span class="keyword">update</span> total_amount <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> od <span class="operator">=</span> <span class="number">102</span>;</span><br></pre></td></tr></table></figure>

<p>这些操作都是比较重的操作，不要频繁进行这些修改动作。重指的是语句会分两步执行，第一步是进行增加数据增加分区，第二步在旧分区行上面打上逻辑删除标识。当进行数据合并的时候，会进行真正的数据操作。</p>
<p>可以通过在建表时添加版本号或者类似的标记字段等，来实现 “插入实现更新” 这个功能，也可以通过 AggregationMergeTree 这个引擎</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> xxx &#123;</span><br><span class="line">colName     SimpleAggregateFunction(anyLast, Nullable (UInt32))</span><br><span class="line">&#125;engine <span class="operator">=</span> ReplicatedAggregatingMergeTree()</span><br></pre></td></tr></table></figure>

<p>不过这个建表语句可能更适合更新某一个字段，即现在有 c1,c2 两个字段，然后可能单独去更新 c2 这个字段，那么插入数据之后结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c1  c2</span><br><span class="line">v1  v2</span><br><span class="line">null v2&#x27;</span><br></pre></td></tr></table></figure>

<p>在查询的时候加上 final，会自动去获取最新的不为 null 的值，返回结果就是 <code>v1, v2&#39;</code>，通过插入来实现更新，但是这样的话，会导致结果里出现 null 值，而 ck 在存储时会单独建立一个文件来记录列中的 null 值信息，会影响一定的存储和查询效率</p>
<h3 id="5-副本和分片"><a href="#5-副本和分片" class="headerlink" title="5. 副本和分片"></a>5. 副本和分片</h3><p>副本是为了保证集群的高可用，但是每台服务器实际上必须容纳全量的数据，没有解决数据的<strong>横向扩容</strong>的问题</p>
<p>通过分片将完成的数据进行切分，不同的分片分布到不同的节点上，再通过 Distributed 表引擎将数据拼接起来使用。在实际使用上，分布式表引擎会一定程度上降低查询性能以及在使用上会有一些复杂性，那么可以只使用副本，而不适用分片的方式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> t_order_local <span class="keyword">on</span> cluster cluster_emr (</span><br><span class="line">id UInt32,</span><br><span class="line">sku_id String,</span><br><span class="line">total_amount <span class="type">Decimal</span>(<span class="number">16</span>,<span class="number">2</span>) TTL create_time <span class="operator">+</span> <span class="type">interval</span> <span class="number">10</span> <span class="keyword">SECOND</span>,</span><br><span class="line">create_time DateTime</span><br><span class="line">)engine <span class="operator">=</span>ReplicatedMergeTree(<span class="string">&#x27;/clickhouse/tables/personas/t_order_local/&#123;shard&#125;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&#123;replica&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> toYYYYMMDD(create_time)</span><br><span class="line"><span class="keyword">primary key</span> (id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id</span><br></pre></td></tr></table></figure>

<p>通过上面的语句，会在集群下的每台机器上都创建一张 <code>t_order_local</code> 表，那么在写入数据的时候，可以先去在 <code>system.clusters</code> 这个表里拿到集群下的所有机器 ip，然后在执行 sql 的时候对 ip 进行随机抽取，比如 rand 或者轮询的方式吧，到不同的机器上执行 sql 来缓解机器压力</p>
<blockquote>
<p>  分布式表并不存储真正的数据，做的也近乎是上面的 ip 轮询的一个功能</p>
</blockquote>
<blockquote>
<p>  副本和分片在 ck 里面都是平等的，即没有主从概念</p>
</blockquote>
<blockquote>
<p>  副本之间会自己进行同步，即 副本1 和 副本2 会自己同步，不需要分布式表来执行同步这件事</p>
</blockquote>
<blockquote>
<p>  在读取数据的时候，会优先选择 error_count 小的副本，如果相同，就会随机、按顺序等等方式。比如网络 io 报错，那么 error_count ++</p>
</blockquote>
<h3 id="6-Explain-查看执行计划"><a href="#6-Explain-查看执行计划" class="headerlink" title="6. Explain 查看执行计划"></a>6. Explain 查看执行计划</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain [ AST <span class="operator">|</span> SYNTAX <span class="operator">|</span> PLAN <span class="operator">|</span> PIPELINE ]</span><br><span class="line"><span class="keyword">select</span> ...</span><br></pre></td></tr></table></figure>

<ul>
<li>PLAN: 查看执行计划，默认值</li>
</ul>
<p>— AST: 查看语法树</p>
<ul>
<li>SYNTAX: 查看 ck 基于给定的 sql 进行优化后的 sql 结果</li>
</ul>
<blockquote>
<p>  只能查看 select 语句</p>
</blockquote>
<p>打开三元表达式的优化</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> optimize_if_chain_to_multiif<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>再去查看sql 的优化语法，如果有三元表达式，就会展示优化后的语法 &#x3D;&#x3D;&gt; 会使用 multiif 这个函数</p>
<h3 id="7-表相关优化"><a href="#7-表相关优化" class="headerlink" title="7. 表相关优化"></a>7. 表相关优化</h3><h4 id="7-1-数据类型"><a href="#7-1-数据类型" class="headerlink" title="7.1 数据类型"></a>7.1 数据类型</h4><h4 id="7-1-2-时间"><a href="#7-1-2-时间" class="headerlink" title="7.1.2 时间"></a>7.1.2 时间</h4><p>能不存 string 就不存 string，ck 会自动转换。</p>
<p>同时，虽然 ck 底层将 DateTime 存储为时间戳 Long 类型，但是不建议存 Long 类型，因为 DateTime 不需要经过函数转换处理，执行效率更高</p>
<h4 id="7-1-3-空值"><a href="#7-1-3-空值" class="headerlink" title="7.1.3 空值"></a>7.1.3 空值</h4><p>Nullable 类型几乎总是会影响性能，因为存储 Nullable 列时需要创建一个额外的文件来存储 Null 的标记，并且 Nullable 列无法被索引，可以去使用字段的默认值，而不是去写一个 null</p>
<h4 id="7-2-分区和索引"><a href="#7-2-分区和索引" class="headerlink" title="7.2 分区和索引"></a>7.2 分区和索引</h4><p>分区一般按天分区</p>
<p>索引通过 order by 来指定，通常需要满足查询频率高的列在前面的原则</p>
<h4 id="7-3-表参数"><a href="#7-3-表参数" class="headerlink" title="7.3 表参数"></a>7.3 表参数</h4><p>index_granularity 索引粒度，可以看情况调整</p>
<p>如果表中不需要保证全量数据，可以去添加 TTL 来自动过期历史数据</p>
<h4 id="7-4-写入和删除优化"><a href="#7-4-写入和删除优化" class="headerlink" title="7.4 写入和删除优化"></a>7.4 写入和删除优化</h4><ol>
<li>批量进行插入和删除操作，避免产生大量的小文件</li>
<li>不要一次性写入过多数据，否则因合并速度赶不上写入速度而报错</li>
</ol>
<h3 id="8-CPU-参数"><a href="#8-CPU-参数" class="headerlink" title="8. CPU 参数"></a>8. CPU 参数</h3><p>在 clickhouse 安装目录下，服务端相应的配置在 <code>config.xml</code> 文件中，客户端相应的配置在 <code>users.xml</code></p>
<table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>backgroud_pool_size</td>
<td>后台线程池大小，默认值是 16。条件允许的前提下可以改成 cpu 的个数 * 2</td>
</tr>
<tr>
<td>backgroud_schedule_pool_size</td>
<td>执行后台任务的线程数，默认值是 16，条件允许的前提下可以改成 cpu 的个数 * 2</td>
</tr>
<tr>
<td>max_concurrent_queries</td>
<td>每秒最大处理的请求数，默认值是 100。可以改成 150 - 300</td>
</tr>
<tr>
<td>max_threads</td>
<td>设置单个查询所能使用的最大 cpu 数，默认是 cpu 的个数</td>
</tr>
<tr>
<td>max_insert_threads</td>
<td>针对 insert select，设置并发线程数，默认是 1</td>
</tr>
</tbody></table>
<h3 id="9-内存参数"><a href="#9-内存参数" class="headerlink" title="9. 内存参数"></a>9. 内存参数</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>max_memory_usage</td>
<td>单次查询占用内存的最大值</td>
</tr>
<tr>
<td>max_bytes_before_external_group_by</td>
<td>一般按照 max_memory_usage 的一半设置内存，当 group 使用内存超过阈值后会刷新到磁盘进行 &lt;&#x3D;&#x3D;&#x3D;&gt; clickhouse 聚合分两个阶段：查询并建立中间数据、合并中间数据。所以这一项是上一项的一半内存</td>
</tr>
<tr>
<td>max_bytes_before_external_sort</td>
<td>xx</td>
</tr>
</tbody></table>
<h3 id="10-ck-中的系统表"><a href="#10-ck-中的系统表" class="headerlink" title="10. ck 中的系统表"></a>10. ck 中的系统表</h3><p>某些 sql 如果执行时间超过 30s，那么客户端就会报错，因为掉连接了，此时可以通过查询 <code>system.processes</code> 来查看当前后台正在执行的sql，同时拿到对应的 <code>query_id</code>。</p>
<p>根据 <code>query_id</code> 可以在 <code>query_log</code> 里查到历史查询的 sql 记录，以及是否成功、对应的报错原因、使用资源等等</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">查询clickhouse 表的总行数、压缩前的大小、压缩后的大小、压缩率</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="built_in">sum</span>(<span class="keyword">rows</span>) <span class="keyword">as</span> totalRows,</span><br><span class="line">    formatReadableSize(<span class="built_in">sum</span>(data_uncompressed_bytes)) <span class="keyword">as</span> data_uncompressed,</span><br><span class="line">    formatReadableSize(<span class="built_in">sum</span>(data_compressed_bytes)) <span class="keyword">as</span> data_compressed,</span><br><span class="line">    round(<span class="built_in">sum</span>(data_compressed_bytes) <span class="operator">/</span> <span class="built_in">sum</span>(data_uncompressed_bytes) <span class="operator">*</span> <span class="number">100</span>, <span class="number">0</span>) <span class="keyword">as</span> data_compressed_rate</span><br><span class="line"><span class="keyword">from</span> system.parts</span><br><span class="line"><span class="keyword">where</span> database <span class="operator">=</span> <span class="string">&#x27;rpt&#x27;</span> <span class="keyword">and</span> <span class="keyword">table</span> <span class="operator">=</span> <span class="string">&#x27;test_parquet_local4&#x27;</span>;</span><br><span class="line">按分区来查询clickhouse 表的总行数、压缩前的大小、压缩后的大小、压缩率</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">    `<span class="keyword">partition</span>` <span class="keyword">as</span> par,</span><br><span class="line">    <span class="built_in">sum</span>(<span class="keyword">rows</span>) <span class="keyword">as</span> totalRows,</span><br><span class="line">    formatReadableSize(<span class="built_in">sum</span>(data_uncompressed_bytes)) <span class="keyword">as</span> data_uncompressed,</span><br><span class="line">    formatReadableSize(<span class="built_in">sum</span>(data_compressed_bytes)) <span class="keyword">as</span> data_compressed,</span><br><span class="line">    round(<span class="built_in">sum</span>(data_compressed_bytes) <span class="operator">/</span> <span class="built_in">sum</span>(data_uncompressed_bytes) <span class="operator">*</span> <span class="number">100</span>, <span class="number">0</span>) <span class="keyword">as</span> data_compressed_rate</span><br><span class="line"><span class="keyword">from</span> system.parts</span><br><span class="line"><span class="keyword">where</span> database <span class="operator">=</span> <span class="string">&#x27;rpt&#x27;</span> <span class="keyword">and</span> <span class="keyword">table</span> <span class="operator">=</span> <span class="string">&#x27;test_parquet_local4&#x27;</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> `<span class="keyword">partition</span>`;</span><br><span class="line">通过 processes 表可以拿到当前正在执行的 <span class="keyword">sql</span>，以及 query_id，通过下面 <span class="keyword">sql</span> 可以停止指定的查询</span><br><span class="line">kill query <span class="keyword">where</span> query_id <span class="operator">=</span> <span class="string">&#x27;55edd68a-5a45-4b39-b34a-d82b31f63cec&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="11-zk"><a href="#11-zk" class="headerlink" title="11. zk"></a>11. zk</h3><p>如果在遇到无法创建表（由于表结构已存在或者主键已存在等原因）、无法删除表（表不存在或超出内存无法删除）等等，可以直接在 zk 客户端处理</p>
<p>进入到机器后 <code>sh $ZOOKEEPER_HOME/bin/zkCli.sh</code> 可以启动 zk 客户端</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从根目录开始查看文件</span><br><span class="line">ls <span class="operator">/</span></span><br><span class="line"></span><br><span class="line">一直往下查看，可以看到库下面有哪些表</span><br><span class="line">ls <span class="operator">/</span>clickhouse<span class="operator">/</span>tables<span class="operator">/</span>rpt</span><br><span class="line"></span><br><span class="line">删除库下的某个表</span><br><span class="line">deleteall <span class="operator">/</span>clickhouse<span class="operator">/</span>tables<span class="operator">/</span>rpt<span class="operator">/</span>test_par2_local</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mxxct4git.github.io/2020/10/29/JVM-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda-180.png">
      <meta itemprop="name" content="Mxxct">
      <meta itemprop="description" content="君子不器">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫熊小才天の书院">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/29/JVM-1/" class="post-title-link" itemprop="url">JVM 内存管理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-10-29 16:30:00" itemprop="dateCreated datePublished" datetime="2020-10-29T16:30:00+08:00">2020-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-27 10:46:51" itemprop="dateModified" datetime="2021-01-27T10:46:51+08:00">2021-01-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span id="/2020/10/29/JVM-1/" class="post-meta-item leancloud_visitors" data-flag-title="JVM 内存管理" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/10/29/JVM-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/10/29/JVM-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>7 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="JVM-内存管理"><a href="#JVM-内存管理" class="headerlink" title="JVM 内存管理"></a>JVM 内存管理</h2><p><a href="https://www.cnblogs.com/alsf/p/9017447.html">参考文档</a></p>
<h3 id="1-堆和栈"><a href="#1-堆和栈" class="headerlink" title="1. 堆和栈"></a>1. 堆和栈</h3><p>JVM内存划分：</p>
<ol>
<li>寄存器（程序计数器PC拿到指令地址，放入指令寄存器IR中，cpu执行指令）</li>
<li>本地方法区（本地方法栈）：主要是调用native方法</li>
<li>方法区：记录类的信息，常量等<blockquote>
<p>这个方法区在jdk8之前是叫永久代，存储一些类的信息，方法的信息等类似元数据信息一样的东西，如果程序加载的类过多，也可能会导致OOM。JDK8 把这个区域挪出来，不再保存在虚拟机中，而是本地内存，叫做元空间，这样就不局域于jvm可使用的系统内存。</p>
</blockquote>
</li>
<li>栈内存（stack）<ul>
<li>由编译器自动分配，存放函数的参数值，局部变量的值（定义在方法中的都是局部变量，方法外的是全局变量，for循环内部也是局部变量）</li>
<li>先加载函数才能进行局部变量的定义，所以方法先进栈，再定义变量，变量离开作用域后释放，生命周期都很短</li>
</ul>
</li>
<li>堆内存（heap，不是数据结构中的堆）<ul>
<li>由程序猿分配释放，如果程序猿不释放，程序结束时由GC回收</li>
<li>存储的是数组和对象，凡是new的都在堆中，实体（对象）里面封装了多个数据，一个数据消失，实体不会消失，还可以用，所以堆不会随时释放，会由GC不定时回收</li>
</ul>
</li>
</ol>
<blockquote>
<p>int[] arr &#x3D; new int[3];<br>主函数进栈 -&gt; 在栈中定义一个 arr 变量 -&gt; 在堆里通过new开辟一个空间，这个空间会产生一个地址，这个地址下的所有所有会进行初始化 -&gt; 把内存的地址赋值给 arr<br>int[] arr &#x3D; null; arr不做任何指向，null的作用就是取消引用数据类型的指向</p>
</blockquote>
<h4 id="1-1-堆"><a href="#1-1-堆" class="headerlink" title="1.1 堆"></a>1.1 堆</h4><p>堆又分为</p>
<ul>
<li>新生代<ul>
<li>新生代又被进一步划分为Eden和Survivor区，最后Survivor由FromSpace和ToSpace组成</li>
<li>新建的对象都是由新生代分配内存</li>
<li>新生代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例</li>
</ul>
</li>
<li>老年代<ul>
<li>用于存放新生代中经过多次垃圾回收仍然存活的对象</li>
</ul>
</li>
</ul>
<p><img src="https://images.weserv.nl/?url=https://images2018.cnblogs.com/blog/779030/201805/779030-20180510001611099-127788676.png" alt="堆结构"></p>
<p><img src="https://images.weserv.nl/?url=https://images2018.cnblogs.com/blog/779030/201805/779030-20180510003027516-1618059091.png" alt="堆结构"></p>
<h4 id="1-2-栈"><a href="#1-2-栈" class="headerlink" title="1.2 栈"></a>1.2 栈</h4><p>每个线程执行每个方法的时候都会在栈中申请一个栈帧，每个栈帧包括局部变量区和操作数栈，用于存放此次方法调用过程中的临时变量、参数和中间结果</p>
<p>当一个方法执行结束的时候，方法会出栈，方法内部的变量也会跟着出栈，当局部变量出栈之后，堆中new出来的内存空间就会变的不可达，当GC回收的时候就会去回收那些不可达的区域</p>
<h3 id="2-GC"><a href="#2-GC" class="headerlink" title="2. GC"></a>2. GC</h3><p><a href="https://mp.weixin.qq.com/s/8rj70QaU4ypZ0W5yqpkwvQ">文档1</a><br><a href="https://www.cnblogs.com/aspirant/p/8662690.html">文档2</a><br><a href="https://blog.csdn.net/shlgyzl/article/details/95041113">文档3</a></p>
<p>怎么确定哪些对象应该回收？引用计数方法和可达性分析<br>什么时候回收？cpu空闲自动回收；堆内存满了；主动调用 system.gc()<br>如何回收？四种垃圾回收算法</p>
<h4 id="2-1-垃圾回收算法"><a href="#2-1-垃圾回收算法" class="headerlink" title="2.1 垃圾回收算法"></a>2.1 垃圾回收算法</h4><ol>
<li>引用计数法：有引用就+1，引用失效就-1，等于0的时候清除。缺点：很难解决对象之间互相循环引用的问题。</li>
<li>标记清除法：先标记哪一些需要回收，再清除被标记的对象。缺点：容易产生内存碎片，碎片太多的话后续过程中为大对象分配空间时无法找到足够的空间从而会提前触发一次垃圾回收动作</li>
<li>复制算法：两部分内存，每次只使用一块内存。回收时将a1内存中还存活的对象复制到a2，然后清空整个a1内存。优点：在复制过去的时候相当于有一次整理的动作，不会产生内存碎片，运行高效。缺点：会使可用内存缩减到原来的一半。</li>
<li>标记整理法：先标记，然后把存货的对象移动到一端整理，最后清理掉端边界以外的内存。优点：不产生内存碎片。缺点：成本高</li>
</ol>
<h4 id="2-2-新生代和老年代的GC算法"><a href="#2-2-新生代和老年代的GC算法" class="headerlink" title="2.2 新生代和老年代的GC算法"></a>2.2 新生代和老年代的GC算法</h4><ol>
<li>新生代GC<br> 新生代通常存活时间较短，因此基于<strong>复制算法</strong>来进行回收。新生代内存空间划分为 Eden + S1 + S2（8:1:1），当进行回收的时候，把Eden和S1存活的对象复制到S2上，然后清理掉Eden和S1。</li>
<li>老年代GC<br> 老年代对象存活的时间比较长，比较稳定。因此采用<strong>标记（Mark）算法</strong>来进行回收，所谓标记就是扫描出存活的对象，然后再进行回收未被标记的对象，回收后对用空出的空间要么进行合并，要么标记出来便于下次进行分配，总之就是要减少内存碎片带来的效率损耗</li>
</ol>
<h4 id="2-3-如何是老年代？"><a href="#2-3-如何是老年代？" class="headerlink" title="2.3 如何是老年代？"></a>2.3 如何是老年代？</h4><ol>
<li>大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden和S1S2区产生大量的内存拷贝</li>
<li>长期存活的对象进入老年代。对象每经过一次YGC年龄都会+1，默认阈值是15，达到阈值的对象进入老年代。阈值可以通过 -XX:MaxTenuringThreshold 设置</li>
<li>动态判断对象的年龄。如果Survivor区中存在相同年龄的对象，年龄从小到大进行累加，当加入某个年龄的对象后，累加和超过了Survivor区域大小* TargetSurvivorRatio（默认50%）的时候，从这个年龄往上的所有对象都会挪到老年代。例：年龄1占了33%，年龄2占了33%，年龄3占了34%，因为年龄1+年龄2累加超过了50%，那么年龄2和年龄3都挪到老年代。</li>
</ol>
<h4 id="2-4-什么时候触发GC？"><a href="#2-4-什么时候触发GC？" class="headerlink" title="2.4 什么时候触发GC？"></a>2.4 什么时候触发GC？</h4><ol>
<li>新对象生成，并在Eden申请空间失败时，会触发minorGC即YGC</li>
<li>老年代被写满；持久代被写满；system.gc() 被显示调用；会触发full gc。</li>
</ol>
<h4 id="2-5-垃圾回收器"><a href="#2-5-垃圾回收器" class="headerlink" title="2.5 垃圾回收器"></a>2.5 垃圾回收器</h4><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudaM15Rw47UHovZzmRX7EqHu1cZME2niaJJR0Yf4toicqZvDGV4JIdLFwHRIMR20YwkSgu3omBP1fbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="垃圾回收器"></p>
<ol>
<li>serial<br> <strong>采取复制算法</strong>，用于新生代，单线程收集器，所以在他工作时会产生StopTheWorld。单线程情况下效率更高，比如用于GUI小程序<br> 可以与CMS垃圾回收器一起搭配工作</li>
<li>ParNew<br> <strong>采取复制算法</strong>，用于新生代，是Serial的多线程版本，多个GC线程同时工作，但是也会产生StopTheWorld，因此不能和工作线程并行。<br> 可以与CMS垃圾回收器一起搭配工作</li>
<li>Parallel Scavenge<br> <strong>采取复制算法</strong>，用于新生代，和ParNew一样，所以也会产生STW，多线程收集器，他是吞吐量优先的收集器，提供了很多参数来调节吞吐量。<br> 可以与 Serial Old ， Parallel Old 垃圾回收器一起搭配工作</li>
<li>Serial Old<br> <strong>采取标记整理算法</strong>，用于老年代，单线程收集器，所以在他工作时会产生StopTheWorld。单线程情况下效率更高，比如用于GUI小程序</li>
<li>Parallel Old<br> <strong>采取标记整理算法</strong>，用于老年代，Parallel Scavenge收集器的老年代版本，吞吐量优先。</li>
<li>CMS<br> <strong>采取标记清除算法</strong>，老年代并行收集器，号称以最短STW时间为目标的收集器，并发高、停顿低、STW时间短的优点。主流垃圾收集器之一。</li>
<li>G1<br> <strong>采取标记整理算法</strong>，并行收集器。对比CMS的好处之一就是不会产生内存碎片，此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。而且他的STW停顿时间是可以手动控制一个长度为M毫秒的时间片段（可以用JVM参数 -XX:MaxGCPauseMillis指定），设置完后垃圾收集的时长不得超过这个（近实时）。</li>
</ol>
<blockquote>
<p>新生代都会产生 STW，老年代可能更倾向于 CMS</p>
</blockquote>
<h4 id="2-6-CMS-回收器"><a href="#2-6-CMS-回收器" class="headerlink" title="2.6 CMS 回收器"></a>2.6 CMS 回收器</h4><p>采用标记清除，老年代并行收集器。分为四个阶段</p>
<ol>
<li>初始标记：只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。所以此阶段会产生STW，但时间很短。</li>
<li>并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。不会STW。</li>
<li>重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。STW时间会比第一阶段稍微长点，但是远比并发标记短，效率也很高。</li>
<li>并发清除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。<blockquote>
<p>会产生两次 STW</p>
</blockquote>
</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudaM15Rw47UHovZzmRX7EqHK7474OjbTGA7w5tK8VAGI534XdwcSK8HfsnRsZ3Mw7XHCK5hPMrrsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="CMS"></p>
<p>优点：</p>
<ol>
<li>并发高</li>
<li>停顿短</li>
<li>STW时间短</li>
</ol>
<p>缺点：</p>
<ol>
<li>对cpu资源敏感，并发标记会和用户进程一起占用cpu资源，竞争激烈的话会导致程序变慢</li>
<li>会产生浮动垃圾碎片，在最后一个阶段因为用户进程还在执行，这时候产生的垃圾只能下次再处理</li>
<li>内存碎片问题（因为是标记清除算法）。当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</li>
</ol>
<blockquote>
<p>针对这个内存碎片，有这个开关参数 -XX:+UseCMSCompactAtFullCollection 作用是在full gc 后会做一次碎片整理，但是会导致停顿时间增长，此时就需要另一个参数 -XX:CMSFullGCsBeforeCompaction 这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的</p>
</blockquote>
<blockquote>
<p>CMS 不等于Full GC，我们可以看到CMS分为多个阶段，只有stop the world的阶段被计算到了Full GC的次数和时间，而和业务线程并发的GC的次数和时间则不被认为是Full GC。CMS主要可以分为initial mark(stop the world), concurrent mark, remark(stop the world), concurrent sweep几个阶段，其中initial mark和remark会stop the world。</p>
</blockquote>
<blockquote>
<p>Full GC本身不会先进行Minor GC，我们可以配置，让Full GC之前先进行一次Minor GC，因为老年代很多对象都会引用到新生代的对象，先进行一次Minor GC可以提高老年代GC的速度。比如老年代使用CMS时，设置CMSScavengeBeforeRemark优化，让CMS remark之前先进行一次Minor GC。</p>
</blockquote>
<h4 id="2-7-G1-回收器"><a href="#2-7-G1-回收器" class="headerlink" title="2.7 G1 回收器"></a>2.7 G1 回收器</h4><p>采用标记整理，是针对整个堆的垃圾回收器。分为四个阶段</p>
<ol>
<li>初始标记：仅仅标记GCRoots能直接关联到的对象，且修改TAMS的值让下一阶段用户程序并发运行时能正确可用的Region中创建的新对象。速度很快，会STW。</li>
<li>并发标记：进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。不会STW。</li>
<li>最终标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。STW时间会比第一阶段稍微长点，但是远比并发标记短，效率也很高。</li>
<li>筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</li>
</ol>
<p>特点：</p>
<ul>
<li>并行与并发执行：利用多CPU的优势来缩短STW时间，在GC工作的时候，用户线程可以并行执行。</li>
<li>分代收集：无需其他收集器配合，自己G1会进行分代收集。</li>
<li>空间整合：不会像CMS那样产生内存碎片。</li>
<li>可预测的停顿：可以手动控制一个长度为M毫秒的时间片段（可以用JVM参数 -XX:MaxGCPauseMillis指定），设置完后垃圾收集的时长不得超过这个（近实时）。</li>
</ul>
<p>原理：<br>G1并不是简单的把堆内存分为新生代和老年代两部分，而是把整个堆划分为多个大小相等的独立区域（Region），新生代和老年代也是一部分不需要连续Region的集合。G1跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。</p>
<h3 id="3-JVM-调优"><a href="#3-JVM-调优" class="headerlink" title="3. JVM 调优"></a>3. JVM 调优</h3><ol>
<li><p>一个程序默认的最大堆大小是系统内存的1&#x2F;4，最小堆大小是系统内存的1&#x2F;64</p>
<blockquote>
<p>free -h 查看服务器内存大小<br>jcmd pid help 查看可选的option列表<br>jcmd pid VM.flags 查看当前进程的jvm参数信息<br>-XX:MaxHeapSize&#x3D;memory的四分之一</p>
</blockquote>
</li>
<li><p>如果一个服务器内存32G，运行了100个程序，每一个程序的最大堆大小都是8G，最小堆</p>
</li>
<li><p>一般什么时候去调整 JVM 参数</p>
</li>
</ol>
<ul>
<li>需要大的吞吐量</li>
<li>需要低时延<br>总结来说，原因就是需要快速的响应需求接口，但是如果 GC 的时间特别长，那么就需要去调整堆大小、年轻代大小、老年代大小</li>
</ul>
<ol start="4">
<li><p>查看 GC 信息<br><code>jstat -gc pid</code> 查看进程在此刻的GC相关信息，主要看最后几个参数<br><code>YGC: 次数; YGCT: 时间(秒); FGC: 次数; FGCT: 时间(秒); GCT: 等于前面两个时间之和</code></p>
</li>
<li><p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制<br>&#x3D;&gt; 所以，一般最小堆大小和最大堆大小设置为相等，避免每次GC后要去调整堆的大小</p>
</li>
</ol>
<h4 id="3-1-一些JVM参数"><a href="#3-1-一些JVM参数" class="headerlink" title="3.1 一些JVM参数"></a>3.1 一些JVM参数</h4><ol>
<li>堆设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-Xms:初始（最小）堆大小</span><br><span class="line">-Xmx:最大堆大小</span><br><span class="line">-Xmn:新生代大小 默认是最小堆的1/3，即年轻代和老年代的比例默认是 1:2</span><br><span class="line">-XX:NewRatio:设置新生代和老年代的比值。如：为3，表示年轻代与老年代比值为1：3</span><br><span class="line">-XX:SurvivorRatio:新生代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：为3，表示Eden：Survivor=3：2，一个Survivor区占整个新生代的1/5  </span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold:设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代</span><br><span class="line">-XX:PermSize、-XX:MaxPermSize:分别设置永久代最小大小与最大大小（Java8以前）</span><br><span class="line">-XX:MetaspaceSize、-XX:MaxMetaspaceSize:分别设置元空间最小大小与最大大小（Java8以后）</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>收集器设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC:设置串行收集器</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line"></span><br><span class="line">-XX:+UseParallelGC:设置并行收集器</span><br><span class="line">-XX:+UseParalledlOldGC:设置并行老年代收集器</span><br><span class="line">-XX:+UseConcMarkSweepGC:设置并发收集器</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>垃圾回收统计信息</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC</span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCTimeStamps 打印从启动到发生gc这段时间的一个秒数</span><br><span class="line">-XX:+PrintGCDateStamps 会打印详细的时间信息</span><br><span class="line">-Xloggc:filename</span><br><span class="line">-XX:GCLogFileSize=256M</span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line">-XX:NumberOfGCLogFiles=5</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>并行收集器设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。</span><br><span class="line">-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间</span><br><span class="line">-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>并发收集器设置</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</span><br><span class="line">-XX:ParallelGCThreads=n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。</span><br></pre></td></tr></table></figure>

<h4 id="3-3-栈溢出"><a href="#3-3-栈溢出" class="headerlink" title="3.3 栈溢出"></a>3.3 栈溢出</h4><p>栈溢出一般是因为存在循环递归的情况，有几种优化</p>
<ol>
<li><code>-Xss</code> 这是每个栈可使用的内存大小，即栈大小，如果这个值过小，可能导致栈溢出；如果过大，可能会影响到创建栈的数量，在多线程的情况下，依旧可能溢出</li>
<li>递归的优化 &#x3D;&gt; 尾递归，参考斐波那契的写法。程序会自动优化尾递归，每次循环最后一个栈帧会被替换，而不会多开辟空间。需要有辅助记录的变量。相当于在执行到 base case 的时候，之前的答案也传递过来了，那么就直接 return 就行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span> : F(n - <span class="number">1</span>) + F(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">优化后</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">F</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> a1,<span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? a1 : F(n - <span class="number">1</span>, a2, a1 + a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-HBase-JVM"><a href="#3-4-HBase-JVM" class="headerlink" title="3.4 HBase JVM"></a>3.4 HBase JVM</h4><p>regionServer 向 zk 发送心跳，zk有一个maxSessionTimeout，client自己也会传一个时间，不过zk本身会去做一个计算，来得到一个心跳时间，如果在心跳时间内 rs 没有发送心跳，那么就会认为 rs 下线了。</p>
<p>rs 下线前是在 full gc，而时间过长，导致gc时间超过了心跳时间。</p>
<p>24G<br>-Xmn配置6G， 4-5s一次 minor gc,  耗时300-400ms<br>-Xmn配置2G， 2s左右一次 minor gc,  耗时110ms左右<br>-Xmn配置1G， 1s左右一次或两次 minor gc,  耗时70ms左右</p>
<p>还有一种情况，接口获取的大多是明细数据，会导致数据存放在blockcache中，在数据量大的时候，同时去访问，会导致内存不够。此时需要去调大堆大小。</p>
<blockquote>
<p>blockcache 有两种策略，堆内LruBlockCache和堆外BucketCache</p>
</blockquote>
<h4 id="3-5-Java-程序"><a href="#3-5-Java-程序" class="headerlink" title="3.5 Java 程序"></a>3.5 Java 程序</h4><p>memory 32G<br>程序 堆最大8g 最小512M<br>9521次  146.591秒  60次&#x2F;秒<br>-Xmn配置1G， 1s左右一次或两次 minor gc,  耗时70ms左右</p>
<p>memory 16G<br>程序 堆最大4g 最小256M<br>1294次 9.388秒 138次&#x2F;秒 刚运行没多久就这么多次</p>
<p>2g<br>357次 3.383秒 1天时间内回收了357次，full gc出现2次</p>
<p>-Xmn6g -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction&#x3D;15 -XX:CMSInitiatingOccupancyFraction&#x3D;70 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:&#x2F;data1&#x2F;log&#x2F;hbase&#x2F;gc-hbase.log  -XX:ReservedCodeCacheSize&#x3D;256m -XX:GCLogFileSize&#x3D;256M -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;5</p>
<p>nohup java -Xms2048m -Xmx2048m -Xmn712m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -Xloggc:&#x2F;data&#x2F;label_engine&#x2F;logs&#x2F;gc.log -XX:GCLogFileSize&#x3D;256M -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles&#x3D;5 -jar label-0.0.1-SNAPSHOT.jar –server.port&#x3D;8082  &gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mxxct4git.github.io/2020/12/28/Interview-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda-180.png">
      <meta itemprop="name" content="Mxxct">
      <meta itemprop="description" content="君子不器">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫熊小才天の书院">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/28/Interview-1/" class="post-title-link" itemprop="url">Interview-1</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-12-28 13:54:24" itemprop="dateCreated datePublished" datetime="2020-12-28T13:54:24+08:00">2020-12-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-19 20:55:32" itemprop="dateModified" datetime="2021-01-19T20:55:32+08:00">2021-01-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a>
                </span>
            </span>

          
            <span id="/2020/12/28/Interview-1/" class="post-meta-item leancloud_visitors" data-flag-title="Interview-1" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2020/12/28/Interview-1/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/12/28/Interview-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>16 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Interview-1"><a href="#Interview-1" class="headerlink" title="Interview-1"></a>Interview-1</h2><h3 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1. 线程的状态"></a>1. 线程的状态</h3><ul>
<li>新建(NEW)：新建一个线程</li>
<li>可运行(RUNNABLE)：调用start，等待cpu的使用权</li>
<li>运行(RUNNING)：可运行(RUNNABLE)的线程拿到cpu时间片，开始执行</li>
<li>阻塞(BLOCKED)：指线程因为某种原因放弃了cpu 使用权，即让出了cpu时间片<ul>
<li>等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中</li>
<li>同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。</li>
<li>其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入可运行(runnable)状态。</li>
</ul>
</li>
<li>终止(DEAD)</li>
</ul>
<p><img src="https://images.weserv.nl/?url=http://dl.iteye.com/upload/picture/pic/116719/7e76cc17-0ad5-3ff3-954e-1f83463519d1.jpg"></p>
<h3 id="2-死锁的现象和解决方法"><a href="#2-死锁的现象和解决方法" class="headerlink" title="2. 死锁的现象和解决方法"></a>2. 死锁的现象和解决方法</h3><p>死锁，是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。</p>
<p>死锁产生的四个必要条件：</p>
<ul>
<li>互斥：共享资源同时只能被一个线程访问</li>
<li>占有且等待：线程T1在取得共享资源A的时候，请求等待资源B的时候并不释放资源A。</li>
<li>不可抢占：其他线程不能强行抢占线程的资源。</li>
<li>循环等待条件：线程T1在持有资源A1，同时在请求等待获取资源B，线程T2在持有资源B,然后在请求等待线程T1的持有资源，形成了交叉闭环申请。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>预防<ul>
<li>打破互斥条件。即允许进程同时访问某些资源。但是很多情况有些资源是不支持同时访问的。这个方法基本没用</li>
<li>打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。<strong>当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程</strong>。相当于线程占有的资源被隐蔽强占了。这个方法实现困难，会降低性能</li>
<li>打破占有且等待条件。可以实行资源预先分配策略。如果一个线程所申请的所需的全部资源得不到满足，则不分配任何资源，线程不运行。这个方法会降低线程的并发性</li>
<li>打破循环等待条件，实行资源有序分配策略。需要提前对资源进行分类编号，增加系统开销</li>
</ul>
</li>
<li>避免<ul>
<li>允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待。安全序列的定义：所谓系统是安全的，是指系统中的所有进程能够按照某一种次序分配资源，并且依次地运行完毕，这种进程序列{P1，P2，…，Pn}就是安全序列。如果存在这样一个安全序列，则系统是安全的；如果系统不存在这样一个安全序列，则系统是不安全的。</li>
</ul>
</li>
<li>检测与恢复<ul>
<li>通过检测算法建立线程等待图，如果出现环路则表示有死锁。</li>
<li>通过抢占资源、回退执行、杀掉进程三种方式实现恢复</li>
</ul>
</li>
</ul>
<blockquote>
<p>预防是排除死锁的静态策略，基本没啥用。避免是动态策略，是对线程申请资源这个操作加以限制。但是系统具有并发、共享和随机性等特点，所以也很难实现。主要是检测与恢复，能发现死锁并从死锁中恢复出来。</p>
</blockquote>
<h3 id="3-ConcurrentHashMap-的数量"><a href="#3-ConcurrentHashMap-的数量" class="headerlink" title="3. ConcurrentHashMap 的数量"></a>3. ConcurrentHashMap 的数量</h3><p>由于调用方法的时候可能并发进行增删操作，所以这个数量只是一个估值。</p>
<p>一共有两种方式来获取数量，一个是 <code>size()</code>，如果数量大于int的最大值返回int最大值，根据JDK8注释来看，应该用 <code>mappingCount()</code> 来取代 <code>size()</code>。两个方法底层调用的都是 <code>sumCount()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">sumCount</span><span class="params">()</span> &#123;  </span><br><span class="line">    CounterCell[] as = counterCells; CounterCell a;  </span><br><span class="line">    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> baseCount;  <span class="comment">// 实际上保存的是hashmap中的元素个数  利用CAS锁进行更新，但它并不用返回当前hashmap的元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (as != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; as.length; ++i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((a = as[i]) != <span class="literal">null</span>)  </span><br><span class="line">                sum += a.value; <span class="comment">//所有counter的值求和  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sum;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每一次put操作都会调用 <code>addCount()</code>，通过cas来累加 baseCount，然后查看是否需要扩容。在并发时如果利用CAS修改baseCount失败，会利用CAS操作修改CountCell的值。</p>
<h3 id="4-cas"><a href="#4-cas" class="headerlink" title="4. cas"></a>4. cas</h3><p>基于调用JNI代码实现，借助C来调用CPU底层指令实现。高效轻量，但是有三个问题</p>
<ul>
<li>ABA：借助AtomicStampedReference来解决</li>
<li>循环时间可能很长：</li>
<li>只能保证一个共享变量的原子操作。可以将多个共享变量合并成一个，或者借助AtomicReference类保证引用对象之间的原子性，把多个变量放在一个对象里进行cas操作</li>
</ul>
<h3 id="5-concurrentHashMap-1-7-和-1-8-区别"><a href="#5-concurrentHashMap-1-7-和-1-8-区别" class="headerlink" title="5. concurrentHashMap 1.7 和 1.8 区别"></a>5. concurrentHashMap 1.7 和 1.8 区别</h3><ul>
<li>整体结构<ul>
<li>1.7：segment + hashEntry + unsafe</li>
<li>1.8：移除 segment，使锁的粒度更小， synchronized + CAS + node数组 + unsafe</li>
</ul>
</li>
<li>put<ul>
<li>1.7：先定位segment，再定位桶，全程加锁</li>
<li>1.8：类似于HashMap，直接定位到桶，拿到first节点后进行判断，1、为空则CAS插入；2、为-1则说明在扩容，则跟着一起扩容；3、else则加锁put（类似1.7）</li>
</ul>
</li>
</ul>
<h3 id="6-如何在很短的时间内将大量数据插入到ConcurrentHashMap-如何提高concurrentHashMap的插入效率"><a href="#6-如何在很短的时间内将大量数据插入到ConcurrentHashMap-如何提高concurrentHashMap的插入效率" class="headerlink" title="6. 如何在很短的时间内将大量数据插入到ConcurrentHashMap &#x2F; 如何提高concurrentHashMap的插入效率"></a>6. 如何在很短的时间内将大量数据插入到ConcurrentHashMap &#x2F; 如何提高concurrentHashMap的插入效率</h3><p>主要有两个地方消耗会比较大。一个是扩容操作，一个是锁资源竞争。扩容问题可以通过配置合理的容量大小和扩容因子，尽量减少扩容。锁资源争夺问题，主要是put时会对头结点加上synchronized，优化的一个点可以是锁的等级。将数据根据hash先分类，hash冲突的数据保存在一起，然后使用单线程来put，这样put锁的是同一个头结点，可以将锁控制在偏向锁级别。</p>
<blockquote>
<p>synchronized 级别：偏向锁 -&gt; 轻量锁 -&gt; 重量锁。<br>偏向锁：偏指的是偏向于第一个访问的线程。在无竞争的环境下，有一个线程访问的同步代码块，这个锁就会偏向这个线程，下次访问的时候会检查对象头的mark word记录的是否是当前线程ID，如果是的话就会保持偏向锁，并执行同步代码块。但如果不是偏向锁，就会通过cas来替换线程ID，此时就可能会升级为轻量锁。</p>
</blockquote>
<p><img src="https://images.weserv.nl/?url=https://img2018.cnblogs.com/blog/1088206/201810/1088206-20181009103259832-1994410944.jpg"></p>
<h3 id="7-线程池对工作线程的回收"><a href="#7-线程池对工作线程的回收" class="headerlink" title="7. 线程池对工作线程的回收"></a>7. 线程池对工作线程的回收</h3><blockquote>
<p>线程池的创建主要是通过 ThreadPoolExecutor 这个类来创建的，Executors 类也可以创建，但是不能自定义，类型有限</p>
</blockquote>
<p>线程启动后，就会进入到 <code>runWorker(Worker w)</code> 方法。里面是一个while循环，循环判断任务是否为空，若不为空，执行任务；若取不到任务，或发生异常，退出循环，执行 <code>processWorkerExit(w, completedAbruptly);</code> 在这个方法里把工作线程移除掉。</p>
<p>获取任务主要是 <code>getTask()</code> 方法（还有一个 firstTask，只会执行一次），在不考虑异常的场景下，返回null，就表示退出循环，结束线程。下一步，就得看看，什么情况下 <code>getTask()</code> 会返回null。</p>
<p>两种情况</p>
<ul>
<li>线程池的状态已经是STOP，TIDYING, TERMINATED，或者是SHUTDOWN且工作队列为空</li>
<li>工作线程数已经大于最大线程数或当前工作线程已超时，且，还有其他工作线程或任务队列为空。</li>
</ul>
<blockquote>
<p>当线程池中的线程数小于corePoolSize 时，新提交的任务直接新建一个线程执行任务（不管是否有空闲线程）<br>当线程池中的线程数等于corePoolSize 时，新提交的任务将会进入阻塞队列（workQueue）中，等待线程的调度<br>当阻塞队列满了以后，如果corePoolSize &lt; maximumPoolSize ,则新提交的任务会新建线程执行任务，直至线程数达到maximumPoolSize<br>当线程数达到maximumPoolSize 时，新提交的任务会由(饱和策略)管理<br>任务就理解为生产者消费者中的同步队列</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">    &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">        workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">        workQueue.take();</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    timedOut = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">    timedOut = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果设置了 <code>allowCoreThreadTimeOut(true)</code> 或者当前运行的线程数大于核心线程数，<code>timed = true</code> 此时将从 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 队列里拿出来一个线程执行，如果在规定时间内没取到，就返回null；否则就会 <code>workQueue.take();</code> 所以线程池里的线程一直在等待任务执行不被销毁是因为进入了阻塞状态</p>
<blockquote>
<p>workQueue 一般是 arrayBlockingQueue(或者 linkedBlockingQueue)，至少也是一个阻塞的，当篮子里没有消息的时候，也就是 getTask()</p>
</blockquote>
<h3 id="8-数据库的脏读、不可重复读和幻读"><a href="#8-数据库的脏读、不可重复读和幻读" class="headerlink" title="8. 数据库的脏读、不可重复读和幻读"></a>8. 数据库的脏读、不可重复读和幻读</h3><ul>
<li>脏读：一个事务读取到另一个事务没有提交的数据。我们举个例子：事务A1修改了一行数据，但是还没有提交(还没写入硬盘），这时候事务A2读取了被事务A1修改后的数据，之后事务T1因为一些原因Rollback回滚了，那么事务T2读取的数据就是脏的。<ul>
<li>解决：事务隔离级别调整到READ_COMMITTED</li>
</ul>
</li>
<li>不可重复读：指的是同一个事务， 相同的查询过程读取出了不同的结果。比如说，事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。<ul>
<li>解决：事务隔离级别调整到REPEATABLE_READ</li>
</ul>
</li>
<li>幻读：指的是事务不独立执行的时候，可能出现的错误。比如：A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。<ul>
<li>解决：事务隔离级别调整到SERIALIZABLE_READ</li>
</ul>
</li>
</ul>
<p>隔离级别：</p>
<ul>
<li>DEFAULT</li>
<li>READ_UNCOMMITTED：读未提交，即能够读取到没有被提交的数据，啥也解决不了，很少用</li>
<li>READ_COMMITED：读已提交，即能够读到那些已经提交的数据，自然能够防止脏读</li>
<li>REPEATABLE_READ：重复读取，即在数据读出来之后加锁，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录</li>
<li>SERLALIZABLE：串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务</li>
</ul>
<h3 id="9-TCP和UDP"><a href="#9-TCP和UDP" class="headerlink" title="9. TCP和UDP"></a>9. TCP和UDP</h3><ul>
<li>TCP：面向连接，三次握手，传输可靠</li>
<li>UDP：传输数据前不需要建立连接，适合传输大量数据，但是不可靠，容易丢包，比如直播视频，丢帧就丢了</li>
</ul>
<h3 id="10-BIO、NIO、AIO-select-poll、epoll"><a href="#10-BIO、NIO、AIO-select-poll、epoll" class="headerlink" title="10. BIO、NIO、AIO &amp; select&#x2F;poll、epoll"></a>10. BIO、NIO、AIO &amp; select&#x2F;poll、epoll</h3><p>举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在哪里傻等着水开（<strong>同步阻塞</strong>）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（<strong>同步非阻塞</strong>）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（<strong>异步非阻塞</strong>）。</p>
<ul>
<li>BIO：同步阻塞。通过线程池的方式来对每一个请求提供应答，但是无法应对海量的请求并发</li>
<li>NIO：同步非阻塞。在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。  <ul>
<li>NIO 和 BIO 的区别：<ul>
<li>IO流是阻塞的，NIO流是非阻塞的</li>
<li>IO面向流，而NIO面向缓冲区。所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</li>
<li>NIO 通过Channel（通道） 进行读写。通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</li>
<li>NIO有选择器，而IO没有。选择器用于使用单个线程处理多个通道。避免了线程之间的切换，可以直接将线程通过select挂在到不同的channel下</li>
</ul>
</li>
<li>NIO 读写数据的方式<ul>
<li>从channel读取：创建一个缓冲区，请求通道读取数据</li>
<li>从channel写入：创建一个缓冲区，填充数据，并要求通道写入数据<blockquote>
<p>NIO 底层是由 epoll 实现，但是空轮询会导致cpu飙升 &#x3D;&#x3D;&gt; netty</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>AIO：异步非阻塞。协程</li>
</ul>
<p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20200709203708724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjQ0Nzk1OQ==,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>同步阻塞IO：请求数据的线程会一直阻塞，知道准备好数据</li>
<li>同步非阻塞IO：用户态请求数据，如果内核态数据没准备好，用户态的线程可以去做别的，但是会不断询问数据是否准备好</li>
<li>多路复用IO（NIO）：用户态线程不断去询问，消耗CPU资源 &#x3D;&#x3D;&gt; 有三种方式（select、poll、epoll），根本思想是将用户态的不断轮询交给内核态去做，其中selcet\poll是轮询的方式，epoll不是轮询。内核态准备好数据后，也不需要只找那个请求数据的线程，找其他用户态等着的线程来处理接下来的事情就好。<ul>
<li>select：把需要的数据fd放到一个set里，因为是set所以有数量限制，在内核态不断轮询。缺点是线性轮询，效率低；用户态和内核态的复制非常消耗资源</li>
<li>poll：将set替换为链表的方式，这样就没有数量限制</li>
<li>epoll：示例如Nginx。不像前两个把fd放到一个集合里遍历，而是采用<strong>注册回调函数</strong>，在fd准备好的时候触发回调函数，把fd放到就绪队列，直接返回，这样就避免了遍历所有的fd，时间从O(n)变到O(1)</li>
</ul>
</li>
</ul>
<h3 id="11-linux下的java进程和linux线程有一一对应的关系吗"><a href="#11-linux下的java进程和linux线程有一一对应的关系吗" class="headerlink" title="11. linux下的java进程和linux线程有一一对应的关系吗"></a>11. linux下的java进程和linux线程有一一对应的关系吗</h3><p>如果线程有50%的时间被阻塞，线程的数量就应该是内核数量的2倍。如果更少的比例被阻塞，那么它们就是计算密集型的，则需要开辟较少的线程。如果有更多的时间被阻塞，那么就是IO密集型的程序，则可以开辟更多的线程。于是我们可以得到下面的线程数量计算公式：</p>
<p>线程数量&#x3D;内核数量 &#x2F; （1 - 阻塞率）</p>
<h3 id="12-JVM-哪一些是线程独占哪一些是线程共享"><a href="#12-JVM-哪一些是线程独占哪一些是线程共享" class="headerlink" title="12. JVM 哪一些是线程独占哪一些是线程共享"></a>12. JVM 哪一些是线程独占哪一些是线程共享</h3><p><img src="https://images.weserv.nl/?url=https://images2015.cnblogs.com/blog/820406/201603/820406-20160326200119386-756216654.png"></p>
<ul>
<li><p>线程独占：栈、本地方法栈、程序计数器</p>
</li>
<li><p>线程独享：堆、方法区</p>
</li>
<li><p>栈：线程在执行每个方法时都会同时创建一个栈帧，用来存储局部变量表、操作栈、动态链接、方法出口等信息。调用方法时执行入栈，方法返回时执行出栈。</p>
</li>
<li><p>本地技术栈：和Native方法有关</p>
</li>
<li><p>程序计数器：PC寄存器，每个线程都有自己的程序计数器。倘若当前执行的是 JVM 的方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native 方法，则PC寄存器中为空。</p>
</li>
<li><p>堆：所有线程共享，所有的对象和数组都在堆上进行分配。</p>
</li>
<li><p>方法区：主要用于存储类的信息、常量池、方法数据、方法代码等</p>
</li>
</ul>
<h3 id="13-JDK8-永久代和元空间"><a href="#13-JDK8-永久代和元空间" class="headerlink" title="13. JDK8 永久代和元空间"></a>13. JDK8 永久代和元空间</h3><p>永久代（PermGen space）：指的是方法区，但是和方法区有本质的区别。方法区是JVM的规范，永生代是JVM规范的一种实现，并且只有 HotSpot 才有永生代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。</p>
<blockquote>
<p>JVM 是一种规范，hotspot是虚拟机的一种实现方式。openjdk项目包括hostspot这个组件</p>
</blockquote>
<p>在JDK8中，HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。</p>
<p>元空间（Metaspace）：7将永久代移动到了堆（比如字符串常量移到了堆），8已经不存在永久代了。元空间的本质和永久代类似，都是对方法区的一种实现，但是最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此默认情况下，元空间的大小仅受本地内存限制，但是可以通过参数来指定元空间的大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。</span><br><span class="line">-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</span><br><span class="line"></span><br><span class="line">除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：</span><br><span class="line">-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集</span><br><span class="line">-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</span><br></pre></td></tr></table></figure>

<h3 id="14-Linux-分段"><a href="#14-Linux-分段" class="headerlink" title="14. Linux 分段"></a>14. Linux 分段</h3><h3 id="15-抽象类和接口"><a href="#15-抽象类和接口" class="headerlink" title="15. 抽象类和接口"></a>15. 抽象类和接口</h3><p>JDK8 允许在接口中定义 static 方法和 default 方法，其中default方法可以选择重写；static 方法比如通过接口类调用，原因是一个类可能实现两个接口，如果两个接口类中的static方法一样，就会发现错误，所以需要指定接口类来调用static方法</p>
<p>抽象类就是对一类事物的共性东西提取出来；接口则是一种规范，许多情况下接口可以代替抽象类，毕竟Java单继承多实现</p>
<h3 id="16-synchronized-和-ReentrantLock的区别"><a href="#16-synchronized-和-ReentrantLock的区别" class="headerlink" title="16. synchronized 和 ReentrantLock的区别"></a>16. synchronized 和 ReentrantLock的区别</h3><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>
<ul>
<li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ul>
<p>另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。</p>
<h3 id="17-怎么唤醒一个阻塞的线程"><a href="#17-怎么唤醒一个阻塞的线程" class="headerlink" title="17. 怎么唤醒一个阻塞的线程"></a>17. 怎么唤醒一个阻塞的线程</h3><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。</p>
<h3 id="18-int和Integer的区别，为什么有了int还要有设计Integer"><a href="#18-int和Integer的区别，为什么有了int还要有设计Integer" class="headerlink" title="18. int和Integer的区别，为什么有了int还要有设计Integer"></a>18. int和Integer的区别，为什么有了int还要有设计Integer</h3><p>区别：</p>
<ul>
<li>int 是基本数据类型， Integer 是包装类</li>
<li>Integer 必须实例化后才能使用</li>
<li>Integer 实际是对象的引用，指向new出来的对象；int 是直接存储数值</li>
<li>Integer 默认值是null， int默认值是0</li>
</ul>
<p>深入：</p>
<ul>
<li>两个通过new生成的Integer变量永远是不相等的。因为new生成的是两个对象，其内存地址不同。</li>
<li>Integer与new Integer不会相等。因为非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的地址不同。</li>
<li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。<ul>
<li>java在编译Integer i &#x3D; 127的时候,被翻译成 Integer i &#x3D; Integer.valueOf(127);  java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i &#x3D; 127时，会将127这个Integer对象进行缓存，下次再写Integer j &#x3D; 127时，就会直接从缓存中取，就不会new了。</li>
</ul>
</li>
<li>Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true。（因为包装类Integer和基本数据类型int比较时，java会自动拆箱为int，然后进行比较，实际上就变为两个int变量的比较）</li>
</ul>
<p>对象封装有很多好处，可以把属性也就是数据跟处理这些数据的方法结合在一起，比如Integer就有parseInt()等方法来专门处理int型相关的数据。<br>另一个非常重要的原因就是在Java中绝大部分方法或类都是用来处理类类型对象的，如ArrayList集合类就只能以类作为他的存储对象，而这时如果想把一个int型的数据存入list是不可能的，必须把它包装成类，也就是Integer才能被List所接受。所以Integer的存在是很必要的。</p>
<h3 id="19-Executor封装的四种线程池类型"><a href="#19-Executor封装的四种线程池类型" class="headerlink" title="19. Executor封装的四种线程池类型"></a>19. Executor封装的四种线程池类型</h3><ul>
<li>newCachedThreadPool：可缓存的线程池，最大线程数无上限（int最大值）</li>
<li>newFixedThreadPool：固定大小的线程池，所有的线程都是核心线程，没有空闲等待时间</li>
<li>newSingleThreadExecutor：单线程的线程池，相当于单线程串行执行所有任务</li>
<li>newScheduledThreadPool：最大线程数无上限，可设置核心线程数。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h3 id="20-线程池为什么要使用阻塞队列而不使用非阻塞队列？"><a href="#20-线程池为什么要使用阻塞队列而不使用非阻塞队列？" class="headerlink" title="20. 线程池为什么要使用阻塞队列而不使用非阻塞队列？"></a>20. 线程池为什么要使用阻塞队列而不使用非阻塞队列？</h3><p>阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，释放cpu资源。<br>当队列中有任务时才唤醒对应线程从队列中取出消息进行执行。<br>使得在线程不至于一直占用cpu资源。</p>
<h3 id="21-常用的并发工具类有哪些？线程之间的互相通信"><a href="#21-常用的并发工具类有哪些？线程之间的互相通信" class="headerlink" title="21. 常用的并发工具类有哪些？线程之间的互相通信"></a>21. 常用的并发工具类有哪些？线程之间的互相通信</h3><ul>
<li>CountDownLatch<ul>
<li>就是一个线程等待，直到它所等待的其他线程都执行完成并且调用 countDown() 方法发出通知后，当前线程才可以继续执行</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123; &#125;;   </span><br><span class="line"><span class="comment">//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123; &#125;;  </span><br><span class="line"><span class="comment">//将count值减1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countDown</span><span class="params">()</span> &#123; &#125;; </span><br></pre></td></tr></table></figure></li>
<li>CyclicBarrier 是所有线程都在等待，一直到所有线程都准备好进入 await() 方法之后，所有线程同时开始执行</li>
<li>Semaphore</li>
<li>Exchanger</li>
<li>wait\notify\notifyAll</li>
</ul>
<p>CyclicBarrier 和 CountDownLatch 的区别</p>
<ul>
<li>CountDownLatch 只能计算一次，但是 CyclicBarrier 可以 reset</li>
<li>CyclicBarrier 还提供了其他方法，比如 getNumberWaiting 方法可以获得阻塞的线程个数</li>
</ul>
<h3 id="22-volatile"><a href="#22-volatile" class="headerlink" title="22. volatile"></a>22. volatile</h3><ol>
<li>保证可见性</li>
<li>禁止重排序。为了提高性能，系统自动重排序，但是 volatile 这条指令的位置是不可以被改变的。 <code>1 2 volatile 3 4</code> 1和2一定在volatile前面，3和4一定在volatile后面，但是1和2、3和4之前的顺序不能做保证，即可以做重排序</li>
</ol>
<h3 id="23-AQS"><a href="#23-AQS" class="headerlink" title="23. AQS"></a>23. AQS</h3><p><a href="https://juejin.cn/post/6844903903188746247">AQS解析</a></p>
<p>AQS 是一个用来构架锁和同步器的框架，支持三种同步方式</p>
<ul>
<li>独占式<ul>
<li>如 ReentrantLock</li>
</ul>
</li>
<li>共享式<ul>
<li>如 CountDownLatch</li>
</ul>
</li>
<li>组合式<ul>
<li>如 ReentrantReadWriteLock。ReadWriteLock 主要是为了读写锁分离，读锁是共享的，写锁是独占的</li>
</ul>
</li>
</ul>
<h3 id="24-synchronized-中的锁池和等待池"><a href="#24-synchronized-中的锁池和等待池" class="headerlink" title="24. synchronized 中的锁池和等待池"></a>24. synchronized 中的锁池和等待池</h3><p>JVM会为一个使用内部锁（synchronized）的对象维护两个集合，Entry Set 和 Wait Set</p>
<ul>
<li>Entry Set: 如果线程A已经持有了对象锁，此时如果有其他线程也想获得该对象锁的话，它只能进入Entry Set，并且处于线程的BLOCKED状态。</li>
<li>Wait Set: 如果线程A调用了wait()方法，那么线程A会释放该对象的锁，进入到Wait Set，并且处于线程的WAITING状态。</li>
</ul>
<p>对于Entry Set中的线程，当对象锁被释放的时候，JVM会唤醒处于Entry Set中的某一个线程，这个线程的状态就从BLOCKED转变为RUNNABLE。</p>
<p>对于Wait Set中的线程，当对象的notify()方法被调用时，JVM会唤醒处于Wait Set中的某一个线程，这个线程的状态就从WAITING转变为RUNNABLE；或者当notifyAll()方法被调用时，Wait Set中的全部线程会转变为RUNNABLE状态。所有Wait Set中被唤醒的线程会被转移到Entry Set中。</p>
<h4 id="24-1-wait-方法外面为什么是while循环而不是if判断"><a href="#24-1-wait-方法外面为什么是while循环而不是if判断" class="headerlink" title="24.1 wait()方法外面为什么是while循环而不是if判断"></a>24.1 wait()方法外面为什么是while循环而不是if判断</h4><p>普遍是多个线程生产，多个线程消费，如果用 if() 还有可能出现：当一个生产者放入数据后，两个消费者都 if 判断通过，然后过度消费的情况，同理过度生产情况。</p>
<h4 id="24-2-为什么要用notifyAll-方法，用notify-行吗"><a href="#24-2-为什么要用notifyAll-方法，用notify-行吗" class="headerlink" title="24.2 为什么要用notifyAll()方法，用notify()行吗"></a>24.2 为什么要用notifyAll()方法，用notify()行吗</h4><p>c1 c2 拿到锁，发现队列是空，全都 wait()<br>p1 拿到锁，生产，notify()<br>但是此时有可能 p2 也在 Entry Set 里等锁，p2 拿到锁，此时队列是满的，需要 wait()，此时 c1 c2 p2 都在等<br>如果这时候 c1 消费完了，notify()，如果这时候唤醒 p2 没问题，但如果唤醒 c2 会继续等待，万一 p1 不再生产，那么 c2 p2 就会互相等待，造成死锁 &#x3D;&gt; 使用 notifyAll() 的原因就是 notify() 非常容易导致死锁</p>
<h3 id="25-sleep-和-wait-的区别"><a href="#25-sleep-和-wait-的区别" class="headerlink" title="25. sleep 和 wait 的区别"></a>25. sleep 和 wait 的区别</h3><p>如果线程持有某个对象的监视器，那么sleep不会放弃这个对象的监视器，而 wait 会放弃这个监视器。其实就是锁，sleep 不会释放锁</p>
<h3 id="26-线程类的构造方法、静态块是被哪个线程调用的"><a href="#26-线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="26. 线程类的构造方法、静态块是被哪个线程调用的"></a>26. 线程类的构造方法、静态块是被哪个线程调用的</h3><p>线程类的构造方法、静态块是被 new 这个线程类所在的线程所调用的，而 run 方法里面的代码才是被线程自身所调用</p>
<p>假设 Thread2 中 new 了 Thread1，main 函数中 new 了 Thread2，那么</p>
<ol>
<li>Thread2 的构造方法、静态块是 main 线程调用的，Thread2 的 run() 方法是Thread2 自己调用的</li>
<li>Thread1 的构造方法、静态块是 Thread2 调用的，Thread1 的 run() 方法是Thread1 自己调用的</li>
</ol>
<h3 id="27-设计模式"><a href="#27-设计模式" class="headerlink" title="27. 设计模式"></a>27. 设计模式</h3><p>IOC的工厂模式、bean单例模式、装饰者模式、AOP动态代理等。<br>nio：反应器模式<br>redis：基于Reactor模式</p>
<h3 id="28-Redis-线程模型"><a href="#28-Redis-线程模型" class="headerlink" title="28. Redis 线程模型"></a>28. Redis 线程模型</h3><p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20190212140504667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NTI0NjYx,size_16,color_FFFFFF,t_70"></p>
<p>每一个socket对应的fd会注册到epoll中，epoll会监听哪一个socket发送了命令，然后命令会进入队列，被顺序执行。整个过程只在调用select、poll、epoll的时候才会阻塞，socket不会阻塞，收发客户消息不会阻塞，这就是事件驱动，也就是 reactor 模式。</p>
<h3 id="30-并发修改数据库并回写Redis-如何保证数据一致性"><a href="#30-并发修改数据库并回写Redis-如何保证数据一致性" class="headerlink" title="30. 并发修改数据库并回写Redis 如何保证数据一致性"></a>30. 并发修改数据库并回写Redis 如何保证数据一致性</h3><h3 id="31-redis的hash怎么实现的，rehash过程讲一下-和JavaHashMap的rehash有什么区别？redis-cluster怎么做到高可用的？"><a href="#31-redis的hash怎么实现的，rehash过程讲一下-和JavaHashMap的rehash有什么区别？redis-cluster怎么做到高可用的？" class="headerlink" title="31. redis的hash怎么实现的，rehash过程讲一下 和JavaHashMap的rehash有什么区别？redis cluster怎么做到高可用的？"></a>31. redis的hash怎么实现的，rehash过程讲一下 和JavaHashMap的rehash有什么区别？redis cluster怎么做到高可用的？</h3><h3 id="32-raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？"><a href="#32-raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？" class="headerlink" title="32. raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？"></a>32. raft算法的基本流程？raft算法里面如果出现脑裂怎么处理？</h3><h3 id="33-paxos和zookeeper的zab算法，他们之前有啥区别？"><a href="#33-paxos和zookeeper的zab算法，他们之前有啥区别？" class="headerlink" title="33. paxos和zookeeper的zab算法，他们之前有啥区别？"></a>33. paxos和zookeeper的zab算法，他们之前有啥区别？</h3><h3 id="34-删除链表的倒数第-N-个节点"><a href="#34-删除链表的倒数第-N-个节点" class="headerlink" title="34. 删除链表的倒数第 N 个节点"></a>34. 删除链表的倒数第 N 个节点</h3><p>双指针，first 第一次先移动N个节点，second移动一个节点，之后first和second都移动一个节点，直到first.next&#x3D;null，删除second对应的节点</p>
<h3 id="35-树"><a href="#35-树" class="headerlink" title="35. 树"></a>35. 树</h3><p>B-(B)树 多路搜索树<br>b+树在b树基础上，叶子结点增加链表指针，非叶子结点是叶子节点的索引<br>b*树在b+树基础上，非叶子结点也增加链表指针</p>
<p>二叉树最坏情况会变成线性结构，时间是O(n)。avl 二叉平衡树要求左右子树的最大高度不超过1，通过自旋来保证结构，从而保证时间是O(logn)<br>红黑树属于不严格的avl，不严格指的是不用严格去控制高度，这就保证了插入效率的提高。而查找的话，由于avl更平衡，所以avl的效率要比红黑树平均要高。红黑树算是空间换时间</p>
<p>B+树更适合做数据库索引的原因：磁盘读写代价更低，b树所有节点都有数据，导致要查找的时候一页数据更少；b+树的查询效率更稳定，任何查询都需要从根走到叶子<br>B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。<br>B+树的缺点：会产生大量的随机IO。原因是随着数据的插入，逻辑上连续的叶子节点往往会在物理上不连续，无法甚至分隔很远，导致在做范围查询的时候，会产生大量的随机IO &#x3D;&gt; 主要是由于数据全在磁盘，如果数据相距很远，磁盘寻址很慢</p>
<p>LSM树（Log-Structured Merge-Trees）：把一颗大树拆分成n棵小树，先写入内存，在内存中构建一颗有序的小树，在到达一定大小后刷到磁盘。读数据的时候，由于不知道数据在哪棵小树，所以需要遍历所有的小树，每棵小树都是有序的 &#x3D;&gt; 牺牲了部分读性能，大幅提高写性能<br>由此推到HBase的一些概念：</p>
<ul>
<li>WAL：为了避免因为断电导致内存中的数据会丢失，所以先在磁盘上记录logfile，然后写到内存中，当数据刷到磁盘后，logfile就可以删除了</li>
<li>memstore、storeFile：内存中的小树就是memstore，每次flush，内存中的memstore就会变成磁盘上的storeFile</li>
<li>compact：小树过多，会影响到读的性能，所以需要不定时合并小树</li>
</ul>
<blockquote>
<p>hbase 使用跳表来保证内存memstore中key是有序的<br>MemTable 是内存中的数据结构，当MemTable到一定大小后，会转化成Immutable MemTable，这是将 MemTable 转成 SSTable 的一种中间状态。写操作会由新的 MemTable 处理。<br>SSTable 是有序键值对集合，是LSM树在磁盘中的数据结构，为了加快读取，可以建立索引以及布隆过滤器来加快key的查找</p>
</blockquote>
<h3 id="36-mysql-的索引"><a href="#36-mysql-的索引" class="headerlink" title="36. mysql 的索引"></a>36. mysql 的索引</h3><p>innoBD 引擎，主键是聚簇索引，如果不指定主键，将第一个列都是not null的唯一索引作为聚簇索引；每个innnoDB<strong>有且仅有</strong>有一个聚簇索引<br>再创建的都是非聚簇索引，在叶子节点会记录主键的值，然后指向聚簇索引的叶子节点<br>整个过程从K索引树到主键索引树的过程叫做<strong>回表</strong></p>
<blockquote>
<p>主索引（聚簇索引）叶子节点会保存整条数据，辅助索引（非聚簇索引）会保存指定的列+主键的数据，如果查询的时候列大于辅助索引中的列，那么就会根据查询到的id去主索引里继续查，也就是回表</p>
</blockquote>
<p><img src="https://images.weserv.nl/?url=https://img3.sycdn.imooc.com/5d24c29b0001590909470341.jpg"></p>
<h3 id="37-处理海量数据思路"><a href="#37-处理海量数据思路" class="headerlink" title="37. 处理海量数据思路"></a>37. 处理海量数据思路</h3><ol>
<li>分而治之&#x2F;hash映射 + hash统计 + 堆&#x2F;快速&#x2F;归并排序</li>
<li>双层桶划分</li>
<li>Bloom filter&#x2F;Bitmap</li>
<li>Trie树&#x2F;数据库&#x2F;倒排索引</li>
<li>外排序</li>
<li>分布式处理之Hadoop&#x2F;Mapreduce</li>
</ol>
<h3 id="38-一个线程死循环，另一个线程还能不能执行"><a href="#38-一个线程死循环，另一个线程还能不能执行" class="headerlink" title="38. 一个线程死循环，另一个线程还能不能执行"></a>38. 一个线程死循环，另一个线程还能不能执行</h3><p>要看死循环的线程占用的是什么锁，如果是自己的锁，那没事，另一个线程还可以被执行到；但如果两个线程占用的是同一个对象的锁，一个死循环，那另一个就执行不了</p>
<h3 id="39-Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"><a href="#39-Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么" class="headerlink" title="39. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"></a>39. Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</h3><p>ISR:In-Sync Replicas 副本同步队列<br>AR:Assigned Replicas 所有副本<br>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR。</p>
<h3 id="40-Yarn的调度方式"><a href="#40-Yarn的调度方式" class="headerlink" title="40. Yarn的调度方式"></a>40. Yarn的调度方式</h3><ol>
<li>先进先出<ul>
<li>有可能会导致大量的小作业得不到执行</li>
</ul>
</li>
<li>容器<ul>
<li>先划分一部分资源看做一个容器，专门用来运行小作业，缺点就是为小任务专门设置一个队列会预先占用一定的集群资源，这就导致大任务的执行时间会落后于使用FIFO调度器时的时间</li>
</ul>
</li>
<li>公平<ul>
<li>只有一个job的时候，占用所有的资源；提交第二个job，会平分资源，使两个job共享集群资源</li>
</ul>
</li>
</ol>
<h3 id="41-kafka-的数据积压"><a href="#41-kafka-的数据积压" class="headerlink" title="41. kafka 的数据积压"></a>41. kafka 的数据积压</h3><p>积压就是生产者速度 &gt; 消费者速度<br>解决思路：</p>
<ol>
<li>重启作业从上一次提交的offset开始重新执行</li>
<li>有可能是因为partition不够，导致数据过于集中，那么可以尝试增多partiton</li>
<li>减少每一次batch的数据量大小，略微提高获取batch的频率，勤拿少取</li>
<li>有可能存在数据倾斜，单纯是数据其中在某些partition里，那么就尝试在key前面加上随机数，打散数据</li>
</ol>
<h3 id="42-在hbase表中插入大量数据"><a href="#42-在hbase表中插入大量数据" class="headerlink" title="42. 在hbase表中插入大量数据"></a>42. 在hbase表中插入大量数据</h3><p>Region会不断增大，不停的split，会影响效率 &#x3D;&gt; 进行分区，控制region的个数 &#x3D;&gt; split 或者 加盐</p>
<h3 id="43-hive-中的-union和union-all"><a href="#43-hive-中的-union和union-all" class="headerlink" title="43. hive 中的 union和union all"></a>43. hive 中的 union和union all</h3><p>union 是 union distinct 的缩写，使用 union 的话会对select出来的列中的重复值进行<strong>去重并排序</strong></p>
<p>union all 就是单纯把列的结果合并在一起，不去重不排序</p>
<h3 id="44-十台机器同时去执行一条命令"><a href="#44-十台机器同时去执行一条命令" class="headerlink" title="44. 十台机器同时去执行一条命令"></a>44. 十台机器同时去执行一条命令</h3><p>list.txt 中去写入一些机器的ip</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in `cat ./allhosts`; do echo $i; ssh $i &quot;service ntpd restart&quot;;done</span><br></pre></td></tr></table></figure>

<h3 id="45-flink中的-dataset-和-datastream"><a href="#45-flink中的-dataset-和-datastream" class="headerlink" title="45. flink中的 dataset 和 datastream"></a>45. flink中的 dataset 和 datastream</h3><ul>
<li>dataset 中的 source 来源于文件、表或者 Java 集合</li>
<li>datastream 中的 source 一般是消息中间件比如 Kafka</li>
</ul>
<h3 id="46-咆哮位图"><a href="#46-咆哮位图" class="headerlink" title="46. 咆哮位图"></a>46. 咆哮位图</h3><p>N&#x2F;65536 &#x3D; block_id<br>N%65536 &#x3D; 在对应的block内的一个偏移量</p>
<p>将位图分block，每一个值都放到对应的block的位置上</p>
<h3 id="47-HDFS-小文件"><a href="#47-HDFS-小文件" class="headerlink" title="47. HDFS 小文件"></a>47. HDFS 小文件</h3><ol>
<li>如果是hive的话</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hive.merge.mapfiles</span><br><span class="line">hive.merge.mapredfiles</span><br><span class="line">hive.merge.size.per.task</span><br><span class="line">hive.merge.smallfiles.avgsize</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果是已有的小文件</li>
</ol>
<p>Hadoop 自带三个方案，Hadoop Archive，Sequence file和CombineFileInputFormat。</p>
<ul>
<li>Hadoop Archive：主要是用来归档，如果其中小文件出现问题，需要重新归档，因为中间涉及到索引信息的更改等；另外如果作为mr的输入路径，那么还是一个小文件对应一个map</li>
<li>Sequence file：可以做压缩；支持splitable，那么就可以作为mr的输入；但是需要自己编写程序来实现，另外由于是二进制文件，不方便查看</li>
<li>CombineFile：也是基于mr来进行转换，如果要合并的小文件很多，那么最终合并的文件会包含过多的额外信息，浪费过多的空间，所以这种方案目前相对用得比较少</li>
</ul>
<h3 id="48-flink-数据积压"><a href="#48-flink-数据积压" class="headerlink" title="48. flink 数据积压"></a>48. flink 数据积压</h3><h3 id="49-hive参数调优"><a href="#49-hive参数调优" class="headerlink" title="49. hive参数调优"></a>49. hive参数调优</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.parrallel=true; # 针对类似union all这样的，操作相互不关联的情况，可以设置并行度</span><br><span class="line">set hive.exec.parallel.thread.number=8; # 并行度的个数</span><br><span class="line"></span><br><span class="line">set hive.map.aggr=true; # 在map端进行聚合</span><br><span class="line">set hive.groupby.mapaggr.checkinterval=100000; # 在map端进行聚合操作的数据条数</span><br><span class="line"></span><br><span class="line"># 在数据分布不均时，即发生倾斜时进行负载均衡，可以进行如下的参数设置</span><br><span class="line">set hive.groupby.skewindata=true; # 生成的查询计划会有两个MR Job。第一个MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key有可能被分发到不同的Reduce 中，从而达到负载衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中，最后完成最终的聚合操作 # 类似于mapreduce中加一个combine</span><br><span class="line"></span><br><span class="line"># join出现数据倾斜时，需要设置参数</span><br><span class="line">set hive.skewjoin.key=10000; # 这个是join的键对应的记录条数超过这个值则会进行分拆</span><br><span class="line">set hive.optimize.skewjoin=true; # 如果是join 过程出现倾斜 应该设置为true</span><br><span class="line"></span><br><span class="line">set mapred.max.split.size=xx; # map前合并小文件</span><br><span class="line">set hive.merge.mapfiles=true; # map结束后合并小文件</span><br><span class="line">set hive.merge.mapredfiles=true; # 合并reduce输出文件</span><br></pre></td></tr></table></figure>

<h3 id="50-NameNode-单点故障"><a href="#50-NameNode-单点故障" class="headerlink" title="50. NameNode 单点故障"></a>50. NameNode 单点故障</h3><blockquote>
<p>HDFS1 是一个namenode，一个secondarynamenode，元数据放在内存里，会出现单点问题和内存受限问题</p>
</blockquote>
<p>两个NameNode，会去竞争ZK中的一把锁，谁抢到了谁就是active节点，类似于kafka的controller和follower，controller主要是为了同步元数据，然后follower去同步，所以kafka每一个broker都会有元数据</p>
<p>每个NameNode都有一个进程 ZKFC，会向zk汇报心跳情况，如果挂了之后，会自动做切换<br>HDFS的元数据会单独去建一个集群，里面会有2N+1个节点，叫 journalNode，它们会保存元数据信息，能保证这些 journalNode 里的数据都是一样的。<br>Active NameNode 往 journalnode 写元数据，Standby NameNode 从 journalnode 读元数据同步</p>
<h3 id="51-presto-kylin"><a href="#51-presto-kylin" class="headerlink" title="51. presto &amp; kylin"></a>51. presto &amp; kylin</h3><ul>
<li>presto<br>  主要的处理都在内存中，拿一部分数据放内存计算，计算完之后，再拿下一部分数据<br>  如果涉及到多表关联的话，可能内存吃不消</li>
<li>kylin<br>  核心是Cube，cube是一种预计算技术，基本思路是预先对数据作多维索引，查询时只扫描索引而不访问原始数据从而提速。<br>  如果要查询的条件变化太多，没有命中，就会导致计算非常慢；同时导入数据后会需要重新去做cube</li>
</ul>
<h3 id="52-HiveSql报错"><a href="#52-HiveSql报错" class="headerlink" title="52. HiveSql报错"></a>52. HiveSql报错</h3><p>MapReduce<br>FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.mr.MapRedTask</p>
<p>修改hive依赖的hdfs参数：<br>dfs.client.block.write.locateFollowingBlock.retries  &#x3D;  8<br>dfs.client.block.write.retries  &#x3D; 8<br>dfs.client.cached.conn.retry &#x3D; 5</p>
<p>Hive on Spark<br>FAILED: Execution Error, return code 1 from org.apache.hadoop.hive.ql.exec.spark.SparkTask<br>和上面一样，可能最底层的报错原因都是：Unable to close file because the last block does not have enough number of replicas。这说明了在某一时刻可能有任务大量读取blocks，耗费了过多的资源。</p>
<p>解决：</p>
<ol>
<li>排查出读取blocks过多的任务，对该任务进行优化调整，缩短读取的时间范围或通过中间表的形式进行查询，尽可能的不要一次读取过多blocks。</li>
<li>修改hive的参数 同上</li>
</ol>
<p>异常日志定位<br>1、查看Hiveserver2 日志， 使用 return code 找到出现该异常日志的线程编号<br>2、基于线程编号以关键字  Thread-28017]: Running with YARN Application 找到 applicationid<br>3、使用yarn logs -applicationId xx 获取到任务的所有日志信息<br>4、基于关键字 YarnAllocator: Driver requested 找到 spark 任务的 driver<br>5、在driver 日志中用关键字 ERROR， 寻找异常信息， 定位出异常的executor<br>6、找到executor 后， 基本就能找到出错原因</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://mxxct4git.github.io/2021/01/19/Linux-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/panda-180.png">
      <meta itemprop="name" content="Mxxct">
      <meta itemprop="description" content="君子不器">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="猫熊小才天の书院">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/01/19/Linux-3/" class="post-title-link" itemprop="url">Linux 常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-01-19 20:49:56 / Modified: 20:49:58" itemprop="dateCreated datePublished" datetime="2021-01-19T20:49:56+08:00">2021-01-19</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index"><span itemprop="name">Linux</span></a>
                </span>
            </span>

          
            <span id="/2021/01/19/Linux-3/" class="post-meta-item leancloud_visitors" data-flag-title="Linux 常用命令" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2021/01/19/Linux-3/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/01/19/Linux-3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><h3 id="1-vim"><a href="#1-vim" class="headerlink" title="1. vim"></a>1. vim</h3><ol>
<li>dd 删除一整行，下一行提上来；D删除一整行，光标在行头</li>
<li>S删除一整行并插入，相当于D+i；s 删除当前位置的字符并插入</li>
<li>I 到行首插入；i 在当前光标位置插入</li>
<li>:set nu 行号；:set nonu 取消行号</li>
<li>J 合并当前行和下一行</li>
<li>ctrl+f 向下翻页</li>
<li>ctrl+b 向上翻页</li>
<li>n 向下查找匹配项</li>
<li>N 向上查找匹配项</li>
</ol>
<h3 id="2-端口"><a href="#2-端口" class="headerlink" title="2. 端口"></a>2. 端口</h3><h4 id="2-1-lsof-list-open-files"><a href="#2-1-lsof-list-open-files" class="headerlink" title="2.1 lsof&#x3D;list open files"></a>2.1 lsof&#x3D;list open files</h4><p>lsof -i:3306</p>
<h4 id="2-1-netstat"><a href="#2-1-netstat" class="headerlink" title="2.1 netstat"></a>2.1 netstat</h4><p>netstat -anu&#x2F;-ant</p>
<p>-a 全部<br>-n 显示ip，不是域名<br>-t tcp协议<br>-u udp协议<br>-l或–listening 显示监控中的服务器的Socket<br>-p或–programs 显示正在使用Socket的程序识别码和程序名称</p>
<p>查看网络连接状况<br>netstat -an</p>
<p>如何统计系统当前进程连接数<br>netstat -an | grep ESTABLISHED | wc -l</p>
<p>用 netstat 命令配合其他命令，按照源 IP 统计所有到 80 端口的 ESTABLISHED 状态链接的个数<br>netstat -an|grep ESTABLISHED|grep “:80”|awk ‘BEGIN{FS&#x3D;”[[:space:]:]+”}{print $4}’|sort|uniq -c|sort -nr</p>
<h3 id="3-jvm相关的命令"><a href="#3-jvm相关的命令" class="headerlink" title="3. jvm相关的命令"></a>3. jvm相关的命令</h3><p><a href="https://blog.csdn.net/samyang1/article/details/80557619?utm_medium=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.wap_blog_relevant_pic&depth_1-utm_source=distribute.wap_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.wap_blog_relevant_pic">参考文档</a></p>
<ol>
<li>jps：显示系统内所有的jvm进程</li>
<li>jstat：收集jvm相关的运行数据</li>
<li>jinfo：显示jmv配置信息</li>
<li>jmap：用于生成jvm的快照</li>
<li>jhat：用于分析heapdump文件，可以建立一个http&#x2F;html服务，在浏览器上查看分析结果</li>
<li>jstack：显示jvm的线程快照</li>
<li>jconsole： 一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM</li>
</ol>
<p>jcmd 替换 jmap<br>jcmd pid help 查看可以支持的一些option选项<br>jcmd pid </p>
<h3 id="4-find"><a href="#4-find" class="headerlink" title="4. find"></a>4. find</h3><p>查找指定文件名的文件（不区分大小写）<br>find -iname “xxx”</p>
<p>对找到的文件执行某个命令<br>find -iname “xxx” -exec md5sum {} \</p>
<p>查找home目录下所有空文件<br>find ~ -empty</p>
<p>在&#x2F;usr目录下找出大小超过10M的文件<br>find &#x2F;usr -type f -size +10240k</p>
<p>在&#x2F;var目录下找出90天之内未被访问过的文件<br>find &#x2F;var ! -atime -90</p>
<p>在&#x2F;home目录下找出120天之前被修改过的文件<br>find &#x2F;home -mtime +120</p>
<p>在整个目录树下查找文件，如果发现直接删除<br>find &#x2F; -name “xxx” -exec rm {} \</p>
<h3 id="5-du"><a href="#5-du" class="headerlink" title="5. du"></a>5. du</h3><p>找出磁盘上占空间大的文件或文件夹<br>du -a &#x2F;var | sort -n -r | head -n 10</p>
<h3 id="6-ls-ll"><a href="#6-ls-ll" class="headerlink" title="6. ls&#x2F;ll"></a>6. ls&#x2F;ll</h3><p>按照最后修改时间升序列出文件<br>ll -tr 或者 ls -ltr</p>
<h3 id="7-rsync"><a href="#7-rsync" class="headerlink" title="7. rsync"></a>7. rsync</h3><p>每周一下午3点定时将 &#x2F;tmp&#x2F;logs 目录下所有后缀为 <em>.log 的文件同步到备份服务器同样的目录下<br>crontab -e<br>0 15 * * 1 rsync -avzp &#x2F;tmp&#x2F;logs&#x2F;</em>.log root@ip:&#x2F;tmp&#x2F;logs</p>
<h3 id="8-top"><a href="#8-top" class="headerlink" title="8. top"></a>8. top</h3><p>实时监控系统的cpu和内存，3s刷新一次</p>
<p>包含了前面好几个命令的检查的内容。比如系统负载情况（uptime）、系统内存使用情况（free）、系统 CPU 使用情况（vmstat）等</p>
<h3 id="9-free"><a href="#9-free" class="headerlink" title="9. free"></a>9. free</h3><p>查看内存大小，使用多少，剩余多少</p>
<h3 id="10-less"><a href="#10-less" class="headerlink" title="10. less"></a>10. less</h3><p>打开大文件，vi 会卡，less可以在不加载整个文件的前提下显示文件内容</p>
<p>ctrl+f 上页<br>ctrl+b 下页<br>命令和vi类似</p>
<h3 id="11-grep"><a href="#11-grep" class="headerlink" title="11. grep"></a>11. grep</h3><p>统计文件中包含匹配项的行数<br>grep -c “xxx” file</p>
<p>列出包含匹配项的文件名称<br>grep -l “xxx” file1 file2 file3</p>
<p>正则匹配<br>grep -E “[1-9]+” file</p>
<p>匹配多个内容<br>grep -e “xx” -e “xxxx” file</p>
<h3 id="12-sed"><a href="#12-sed" class="headerlink" title="12. sed"></a>12. sed</h3><p>用 sed 命令将指定的路径 &#x2F;usr&#x2F;local&#x2F;http 替换成为 &#x2F;usr&#x2F;src&#x2F;local&#x2F;http<br>echo “&#x2F;usr&#x2F;local&#x2F;http” | sed ‘s#&#x2F;usr&#x2F;local&#x2F;http#&#x2F;usr&#x2F;src&#x2F;local&#x2F;http#’</p>
<p>echo ‘&#x2F;a’ | sed -e ‘s&#x2F;/&#x2F;x&#x2F;g’ -e ‘s&#x2F;a&#x2F;y&#x2F;g’<br>等价于<br>echo ‘&#x2F;a’ | sed ‘s&#x2F;/a&#x2F;xy&#x2F;g’</p>
<blockquote>
<p># 貌似是把一些特殊字符的转义给省略了。方便直接去做替换</p>
</blockquote>
<p>打印 &#x2F;etc&#x2F;ssh&#x2F;sshd_config 的第一百行<br>sed -n ‘100p’ &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p>
<p>打印第1到3行<br>sed -n ‘1,3p’ &#x2F;etc&#x2F;passwd</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dateTime=$(<span class="built_in">date</span> +%Y%m%d_%H%M%S);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl url &gt; <span class="variable">$dateTime</span>.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">t1=$(sed -n <span class="string">&#x27;196p&#x27;</span> <span class="variable">$dateTime</span>.txt | sed <span class="string">&#x27;s/[[:space:]]//g&#x27;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">t2=$(sed -n <span class="string">&#x27;205p&#x27;</span> <span class="variable">$dateTime</span>.txt | sed <span class="string">&#x27;s/[[:space:]]//g&#x27;</span>);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$dateTime</span> Memory Used: <span class="variable">$t1</span> -- VCores Used: <span class="variable">$t2</span> &gt;&gt; monitor4yarn.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span> -r <span class="variable">$dateTime</span>.txt</span></span><br><span class="line"></span><br><span class="line">t1=1.07TB</span><br><span class="line">unit=$&#123;t1:0-2&#125;;</span><br><span class="line">val=$(echo $&#123;t1&#125; | sed &quot;s/$&#123;unit&#125;//g&quot;);</span><br><span class="line">newVal=$(echo &quot;scale=2;$&#123;val&#125;*1024&quot;|bc)</span><br><span class="line">if [ $unit == &quot;TB&quot; ]</span><br><span class="line">then t1=$&#123;newVal&#125;&quot;GB&quot;</span><br><span class="line">fi </span><br><span class="line">echo $t1</span><br></pre></td></tr></table></figure>

<h3 id="13-awk"><a href="#13-awk" class="headerlink" title="13. awk"></a>13. awk</h3><p>打印第1到3行<br>awk ‘NR&gt;&#x3D;1&amp;&amp;NR&lt;&#x3D;3{print $0}’ &#x2F;etc&#x2F;passwd</p>
<p>awk 可以把文件行内容通过分隔符来划分成不同的域，用 $1 $2 表示，$0 表示整行内容</p>
<h3 id="14-xargs"><a href="#14-xargs" class="headerlink" title="14. xargs"></a>14. xargs</h3><p>将所有图片文件拷贝到外部驱动器<br>ls *.jpg | xargs -n1 -i cp {} &#x2F;external-hard-drive&#x2F;directory</p>
<p>将系统中所有 jpg 文件压缩打包<br>find &#x2F; -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz</p>
<p>下载文件中列出的所有 url 对应的页面<br>cat url-list.txt | xargs wget –c</p>
<p>把当前目录下所有后缀名为 .txt 的文件的权限修改为 777<br>find .&#x2F; -type f -name “<em>.txt” |xargs chmod 777<br>find .&#x2F; -type f -name “</em>.txt” -exec chmod 777 {}</p>
<h3 id="15-man"><a href="#15-man" class="headerlink" title="15. man"></a>15. man</h3><p>显示某个命令的帮助手册<br>man crontab</p>
<p>一个命令也许有好几个man页面，可以先通过 whatis xx 查看命令 xx 有哪些类型，然后通过 man selectNumber xx 查看对应类型号的命令xx的man页面</p>
<h3 id="16-curl"><a href="#16-curl" class="headerlink" title="16. curl"></a>16. curl</h3><p>ping 测试某个地址能否连接，curl 测试某个url是否可以访问</p>
<h3 id="17-shell-脚本"><a href="#17-shell-脚本" class="headerlink" title="17. shell 脚本"></a>17. shell 脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if 条件</span><br><span class="line">then 命令1</span><br><span class="line">else</span><br><span class="line">if 条件</span><br><span class="line">then 命令2</span><br><span class="line">else</span><br><span class="line">命令3</span><br><span class="line">fi</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>大于 -gt</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case 变量 in </span><br><span class="line">值1)</span><br><span class="line">命令1</span><br><span class="line">;;</span><br><span class="line">值2)</span><br><span class="line">命令2</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in item1 itme2 ... itemN</span><br><span class="line">do</span><br><span class="line">命令</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while 条件</span><br><span class="line">do</span><br><span class="line">命令</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="18-如何将标准输出和错误输出同时重定向到同一位置"><a href="#18-如何将标准输出和错误输出同时重定向到同一位置" class="headerlink" title="18. 如何将标准输出和错误输出同时重定向到同一位置"></a>18. 如何将标准输出和错误输出同时重定向到同一位置</h3><p>2&gt;&amp;1<br>ls &#x2F;usr&#x2F;share&#x2F;doc &gt; out.txt 2&gt;&amp;1</p>
<p>&amp;&gt;<br>ls &#x2F;usr&#x2F;share&#x2F;doc &amp;&gt; out.txt</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mxxct"
      src="/images/panda-180.png">
  <p class="site-author-name" itemprop="name">Mxxct</p>
  <div class="site-description" itemprop="description">君子不器</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">127</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">69</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/mxxt" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mxxt" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:386965035@qq.com" title="邮箱 → mailto:386965035@qq.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>邮箱</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mxxct</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">617k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">9:21</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : true,
      notify     : true,
      appId      : 'FeVPpNOBXhL1P240cNkmAKc3-gzGzoHsz',
      appKey     : 'TJ9vKn2xQ16geSxRr80seK0S',
      placeholder: "来说点什么吧~~~",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
